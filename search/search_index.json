{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation 1.1 Governing Equations of Motion Projectile motion is governed by Newton's Second Law of Motion, which states: \\[\\mathbf{F}=m\\mathbf{a}\\] For a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) , we decompose the motion into horizontal and vertical components: Horizontal Motion \\[x(t)=v_0\\cos\\theta\\cdot t\\] Since there is no horizontal acceleration (assuming no air resistance), the horizontal velocity remains constant: \\[v_x=v_0\\cos\\theta\\] Vertical Motion The vertical motion is influenced by gravity \\(g\\) , and follows the kinematic equations: \\[y(t)=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2\\] The vertical velocity is given by: \\[v_y=v_0\\sin\\theta-gt\\] At the peak of the trajectory, the vertical velocity becomes zero: \\[0=v_0\\sin\\theta-gt_{max}\\] Solving for \\(t_{max}\\) : \\[t_{max}=\\frac{v_0\\sin\\theta}{g}\\] The total time of flight is twice this value: \\[T=\\frac{2v_0\\sin\\theta}{g}\\] Governing Differential Equations Horizontal Motion No horizontal acceleration (ignoring air resistance). Velocity in \\(x\\) -direction remains constant: \\[\\frac{d^2x}{dt^2}=0\\] Integrating once: \\[\\frac{dx}{dt}=v_0\\cos(\\theta)\\] Integrating again: \\[x(t)=v_0\\cos(\\theta)\\cdot t\\] 1.2 Derivation of the Range Equation The range \\(R\\) is the horizontal distance traveled when \\(y=0\\) . Using the horizontal motion equation: \\[R=v_xT\\] Substituting \\(v_x=v_0\\cos\\theta\\) and \\(T=\\frac{2v_0\\sin\\theta}{g}\\) : \\[R=v_0\\cos\\theta\\cdot\\frac{2v_0\\sin\\theta}{g}\\] Using the trigonometric identity \\(2\\sin\\theta\\cos\\theta=\\sin2\\theta\\) , we obtain: \\[R=\\frac{v_0^2\\sin2\\theta}{g}\\] 1.3 Influence of Initial Conditions Initial Velocity ( \\(v_0\\) ) : Increasing \\(v_0\\) increases \\(R\\) quadratically. Angle of Projection ( \\(\\theta\\) ) : Maximum range occurs at \\(\\theta=45^\\circ\\) . Gravitational Acceleration ( \\(g\\) ) : A higher \\(g\\) decreases the range. Launch Height ( \\(h\\) ) : If launched from a height \\(h\\) , the total flight time increases, affecting \\(R\\) . Modified Range Equation for Nonzero Initial Height If the projectile is launched from height \\(h\\) , the quadratic equation for time of flight is: \\[y=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2+h=0\\] Solving for \\(t\\) , we get: \\[t=\\frac{v_0\\sin\\theta+\\sqrt{(v_0\\sin\\theta)^2+2gh}}{g}\\] The range then becomes: \\[R=v_0\\cos\\theta\\cdot\\left(\\frac{v_0\\sin\\theta+\\sqrt{(v_0\\sin\\theta)^2+2gh}}{g}\\right)\\] This equation accounts for different launch heights, making it more general. 2. Analysis of the Range 2.1 Governing Equation for Range The horizontal range \\(R\\) of a projectile launched from the ground at an initial velocity \\(v_0\\) and angle \\(\\theta\\) (assuming no air resistance) is given by: \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\] where: \\(v_0\\) is the initial velocity, \\(g\\) is the acceleration due to gravity, \\(\\theta\\) is the launch angle. 2.2 Dependence on the Angle of Projection The function \\(R(\\theta)\\) is determined by the term \\(\\sin(2\\theta)\\) . Since the sine function has a maximum value of 1 at \\(90^\\circ\\) , the range is maximized when: \\[2\\theta=90^\\circ \\Rightarrow \\theta=45^\\circ\\] Thus, the optimal launch angle for maximum range in an idealized scenario is \\(\\theta=45^\\circ\\) . 2.3 Influence of Initial Velocity From the range equation: \\[R \\propto v_0^2\\] This quadratic relationship implies that doubling the initial velocity results in a fourfold increase in range. 2.4 Influence of Gravitational Acceleration Since: \\[R \\propto \\frac{1}{g}\\] A higher gravitational acceleration reduces the range, which explains why projectiles on the Moon (where \\(g\\) is lower) travel much farther than on Earth. 3. Practical Applications 3.1 Introduction In this section, we explore real-world applications of projectile motion, considering various factors such as uneven terrain and air resistance. These cases require advanced mathematical models beyond the idealized equations of motion. 3.2 Projectile Motion on Uneven Terrain When a projectile is launched over an uneven surface, its trajectory is influenced by the varying height of the ground. The general equations of motion in the presence of gravity are given by: \\[ x=v_0\\cos(\\theta)t \\] \\[ y=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2 \\] However, when the ground is not flat but follows a function \\(h(x)\\) , we must solve for the intersection: \\[ v_0\\sin(\\theta)t-\\frac{1}{2}gt^2=h(v_0\\cos(\\theta)t) \\] This requires numerical or analytical techniques depending on the complexity of \\(h(x)\\) . 3.3 Air Resistance in Projectile Motion In realistic scenarios, air resistance significantly affects the projectile's motion. The drag force \\(F_d\\) is modeled as: \\[ F_d=\\frac{1}{2}C_d\\rho A v^2 \\] where: - \\(C_d\\) is the drag coefficient, - \\(\\rho\\) is the air density, - \\(A\\) is the cross-sectional area, - \\(v\\) is the velocity of the projectile. The motion equations with drag become: \\[ m\\frac{dv_x}{dt}=-\\frac{1}{2}C_d\\rho A v v_x \\] \\[ m\\frac{dv_y}{dt}=-mg-\\frac{1}{2}C_d\\rho A v v_y \\] These equations are coupled and typically require numerical integration techniques such as the Runge-Kutta method. 3.4 Computational Approaches To analyze projectile motion with air resistance or uneven terrain, computational methods are often used. The numerical solution can be obtained using Python or MATLAB, employing: Euler\u2019s method Runge-Kutta methods Finite difference approaches These allow us to approximate the trajectory efficiently. 3.5 Conclusion Practical projectile motion problems require considering additional forces and irregular surfaces. Understanding these factors is crucial in fields like aerospace engineering, ballistics, and sports science. The combination of analytical and computational approaches provides deeper insights into real-world projectile dynamics. 4. python/ plot import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, angle, g=9.81): \"\"\" Compute the range of a projectile given initial velocity and launch angle. :param v0: Initial velocity (m/s) :param angle: Launch angle (degrees) :param g: Acceleration due to gravity (m/s^2), default is Earth gravity :return: Range of the projectile (m) \"\"\" theta = np.radians(angle) return (v0**2 * np.sin(2 * theta)) / g def plot_range(v0, g=9.81): \"\"\" Plot range as a function of launch angle. \"\"\" angles = np.linspace(0, 90, num=100) # Angles from 0 to 90 degrees ranges = [projectile_range(v0, angle, g) for angle in angles] plt.figure(figsize=(10, 5)) plt.plot(angles, ranges, label=f'Initial Velocity = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() # Parameters v0 = 20 # Initial velocity in m/s # Run simulation plot_range(v0) link: colab","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations-of-motion","text":"Projectile motion is governed by Newton's Second Law of Motion, which states: \\[\\mathbf{F}=m\\mathbf{a}\\] For a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) , we decompose the motion into horizontal and vertical components:","title":"1.1 Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\[x(t)=v_0\\cos\\theta\\cdot t\\] Since there is no horizontal acceleration (assuming no air resistance), the horizontal velocity remains constant: \\[v_x=v_0\\cos\\theta\\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"The vertical motion is influenced by gravity \\(g\\) , and follows the kinematic equations: \\[y(t)=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2\\] The vertical velocity is given by: \\[v_y=v_0\\sin\\theta-gt\\] At the peak of the trajectory, the vertical velocity becomes zero: \\[0=v_0\\sin\\theta-gt_{max}\\] Solving for \\(t_{max}\\) : \\[t_{max}=\\frac{v_0\\sin\\theta}{g}\\] The total time of flight is twice this value: \\[T=\\frac{2v_0\\sin\\theta}{g}\\]","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-differential-equations","text":"","title":"Governing Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion_1","text":"No horizontal acceleration (ignoring air resistance). Velocity in \\(x\\) -direction remains constant: \\[\\frac{d^2x}{dt^2}=0\\] Integrating once: \\[\\frac{dx}{dt}=v_0\\cos(\\theta)\\] Integrating again: \\[x(t)=v_0\\cos(\\theta)\\cdot t\\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-derivation-of-the-range-equation","text":"The range \\(R\\) is the horizontal distance traveled when \\(y=0\\) . Using the horizontal motion equation: \\[R=v_xT\\] Substituting \\(v_x=v_0\\cos\\theta\\) and \\(T=\\frac{2v_0\\sin\\theta}{g}\\) : \\[R=v_0\\cos\\theta\\cdot\\frac{2v_0\\sin\\theta}{g}\\] Using the trigonometric identity \\(2\\sin\\theta\\cos\\theta=\\sin2\\theta\\) , we obtain: \\[R=\\frac{v_0^2\\sin2\\theta}{g}\\]","title":"1.2 Derivation of the Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-influence-of-initial-conditions","text":"Initial Velocity ( \\(v_0\\) ) : Increasing \\(v_0\\) increases \\(R\\) quadratically. Angle of Projection ( \\(\\theta\\) ) : Maximum range occurs at \\(\\theta=45^\\circ\\) . Gravitational Acceleration ( \\(g\\) ) : A higher \\(g\\) decreases the range. Launch Height ( \\(h\\) ) : If launched from a height \\(h\\) , the total flight time increases, affecting \\(R\\) .","title":"1.3 Influence of Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#modified-range-equation-for-nonzero-initial-height","text":"If the projectile is launched from height \\(h\\) , the quadratic equation for time of flight is: \\[y=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2+h=0\\] Solving for \\(t\\) , we get: \\[t=\\frac{v_0\\sin\\theta+\\sqrt{(v_0\\sin\\theta)^2+2gh}}{g}\\] The range then becomes: \\[R=v_0\\cos\\theta\\cdot\\left(\\frac{v_0\\sin\\theta+\\sqrt{(v_0\\sin\\theta)^2+2gh}}{g}\\right)\\] This equation accounts for different launch heights, making it more general.","title":"Modified Range Equation for Nonzero Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-governing-equation-for-range","text":"The horizontal range \\(R\\) of a projectile launched from the ground at an initial velocity \\(v_0\\) and angle \\(\\theta\\) (assuming no air resistance) is given by: \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\] where: \\(v_0\\) is the initial velocity, \\(g\\) is the acceleration due to gravity, \\(\\theta\\) is the launch angle.","title":"2.1 Governing Equation for Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-dependence-on-the-angle-of-projection","text":"The function \\(R(\\theta)\\) is determined by the term \\(\\sin(2\\theta)\\) . Since the sine function has a maximum value of 1 at \\(90^\\circ\\) , the range is maximized when: \\[2\\theta=90^\\circ \\Rightarrow \\theta=45^\\circ\\] Thus, the optimal launch angle for maximum range in an idealized scenario is \\(\\theta=45^\\circ\\) .","title":"2.2 Dependence on the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#23-influence-of-initial-velocity","text":"From the range equation: \\[R \\propto v_0^2\\] This quadratic relationship implies that doubling the initial velocity results in a fourfold increase in range.","title":"2.3 Influence of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#24-influence-of-gravitational-acceleration","text":"Since: \\[R \\propto \\frac{1}{g}\\] A higher gravitational acceleration reduces the range, which explains why projectiles on the Moon (where \\(g\\) is lower) travel much farther than on Earth.","title":"2.4 Influence of Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-introduction","text":"In this section, we explore real-world applications of projectile motion, considering various factors such as uneven terrain and air resistance. These cases require advanced mathematical models beyond the idealized equations of motion.","title":"3.1 Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-projectile-motion-on-uneven-terrain","text":"When a projectile is launched over an uneven surface, its trajectory is influenced by the varying height of the ground. The general equations of motion in the presence of gravity are given by: \\[ x=v_0\\cos(\\theta)t \\] \\[ y=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2 \\] However, when the ground is not flat but follows a function \\(h(x)\\) , we must solve for the intersection: \\[ v_0\\sin(\\theta)t-\\frac{1}{2}gt^2=h(v_0\\cos(\\theta)t) \\] This requires numerical or analytical techniques depending on the complexity of \\(h(x)\\) .","title":"3.2 Projectile Motion on Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-air-resistance-in-projectile-motion","text":"In realistic scenarios, air resistance significantly affects the projectile's motion. The drag force \\(F_d\\) is modeled as: \\[ F_d=\\frac{1}{2}C_d\\rho A v^2 \\] where: - \\(C_d\\) is the drag coefficient, - \\(\\rho\\) is the air density, - \\(A\\) is the cross-sectional area, - \\(v\\) is the velocity of the projectile. The motion equations with drag become: \\[ m\\frac{dv_x}{dt}=-\\frac{1}{2}C_d\\rho A v v_x \\] \\[ m\\frac{dv_y}{dt}=-mg-\\frac{1}{2}C_d\\rho A v v_y \\] These equations are coupled and typically require numerical integration techniques such as the Runge-Kutta method.","title":"3.3 Air Resistance in Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#34-computational-approaches","text":"To analyze projectile motion with air resistance or uneven terrain, computational methods are often used. The numerical solution can be obtained using Python or MATLAB, employing: Euler\u2019s method Runge-Kutta methods Finite difference approaches These allow us to approximate the trajectory efficiently.","title":"3.4 Computational Approaches"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#35-conclusion","text":"Practical projectile motion problems require considering additional forces and irregular surfaces. Understanding these factors is crucial in fields like aerospace engineering, ballistics, and sports science. The combination of analytical and computational approaches provides deeper insights into real-world projectile dynamics.","title":"3.5 Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-plot","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, angle, g=9.81): \"\"\" Compute the range of a projectile given initial velocity and launch angle. :param v0: Initial velocity (m/s) :param angle: Launch angle (degrees) :param g: Acceleration due to gravity (m/s^2), default is Earth gravity :return: Range of the projectile (m) \"\"\" theta = np.radians(angle) return (v0**2 * np.sin(2 * theta)) / g def plot_range(v0, g=9.81): \"\"\" Plot range as a function of launch angle. \"\"\" angles = np.linspace(0, 90, num=100) # Angles from 0 to 90 degrees ranges = [projectile_range(v0, angle, g) for angle in angles] plt.figure(figsize=(10, 5)) plt.plot(angles, ranges, label=f'Initial Velocity = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() # Parameters v0 = 20 # Initial velocity in m/s # Run simulation plot_range(v0) link: colab","title":"4. python/ plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \ud83d\udcda Theoretical Foundation of the Forced Damped Pendulum 1\ufe0f\u20e3 Formulating the Differential Equation for the Forced Damped Pendulum \u2696\ufe0f The motion of a forced damped pendulum can be described using Newton's Second Law: \\[mL\\frac{d^2\\theta}{dt^2}+b\\frac{d\\theta}{dt}+mg\\sin\\theta=F_0\\cos(\\omega t)\\] where: - \\(m\\) is the mass of the pendulum, - \\(L\\) is the length of the pendulum, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(F_0\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency, - \\(\\theta\\) is the angular displacement. Dividing through by \\(mL\\) : \\[\\frac{d^2\\theta}{dt^2}+\\frac{b}{mL}\\frac{d\\theta}{dt}+\\frac{g}{L}\\sin\\theta=\\frac{F_0}{mL}\\cos(\\omega t)\\] To make the equation more manageable, we define dimensionless parameters: - \\(\\gamma=\\frac{b}{mL}\\) (damping ratio, representing the effect of friction), - \\(\\omega_0^2=\\frac{g}{L}\\) (square of the natural frequency, characterizing the system's oscillation rate), - \\(f=\\frac{F_0}{mL}\\) (scaled external force). This leads to the simplified equation: \\[\\ddot{\\theta}+\\gamma\\dot{\\theta}+\\omega_0^2\\sin\\theta=f\\cos(\\omega t)\\] 2\ufe0f\u20e3 Approximate Solutions for Small-Angle Oscillations \ud83d\udd2c For small angles ( \\(\\theta\\approx\\sin\\theta\\) ), we can linearize the equation: \\[\\ddot{\\theta}+\\gamma\\dot{\\theta}+\\omega_0^2\\theta=f\\cos(\\omega t)\\] This equation describes a damped, driven harmonic oscillator . Using the method of undetermined coefficients, we assume the steady-state solution is of the form: \\[\\theta(t)=A\\cos(\\omega t-\\delta)\\] where: Amplitude \\(A\\) determines the system's response to the driving force: \\( \\(A=\\frac{f}{\\sqrt{(\\omega_0^2-\\omega^2)^2+\\gamma^2\\omega^2}}\\) \\) Phase shift \\(\\delta\\) accounts for the lag due to damping: \\( \\(\\tan\\delta=\\frac{\\gamma\\omega}{\\omega_0^2-\\omega^2}\\) \\) This means the oscillations lag behind the external force , with the delay increasing as damping grows. 3\ufe0f\u20e3 Analysis of Resonance Conditions and Energy Impact \ud83c\udfb5\u26a1 \ud83c\udf1f Resonance: When the System Responds Most Strongly Resonance occurs when the driving frequency matches the system's natural frequency: \\[\\omega\\approx\\omega_0\\] At this point, the denominator of \\(A\\) approaches zero, leading to a large increase in oscillation amplitude . In real-world systems, damping prevents infinite amplitude but still allows significant oscillations. \ud83d\udd0b Energy Considerations The total mechanical energy of the pendulum consists of kinetic and potential energy: \\[E=T+U=\\frac{1}{2}mL^2\\dot{\\theta}^2+mgL(1-\\cos\\theta)\\] For small oscillations, this simplifies to: \\[E\\approx\\frac{1}{2}mL^2\\dot{\\theta}^2+\\frac{1}{2}mgL\\theta^2\\] Under steady-state forced oscillations, energy input from the external force balances the dissipation due to damping. This results in a periodic exchange of energy within the system. \ud83d\udccc Summary \ud83d\udcdd The forced damped pendulum obeys a nonlinear differential equation, which simplifies under small-angle assumptions. Its behavior is characterized by damping, external driving forces, and resonance effects. Resonance occurs when the driving frequency approaches the natural frequency, leading to large oscillations. The system's energy oscillates due to an external force counteracting damping losses. These principles are crucial in engineering, physics, and even biological systems (e.g., heart rhythms, bridges swaying). Understanding them helps in designing stable and efficient mechanical systems! \ud83d\ude80 \ud83d\udd0d Analysis of Dynamics \u2696\ufe0f 2.1 Influence of Damping Coefficient The equation of motion for a damped driven system is given by: \\[m\\ddot{x} + b\\dot{x} + kx = F_0\\cos(\\omega t)\\] where: - \\(m\\) is the mass of the system, determining inertia. - \\(b\\) is the damping coefficient, controlling resistance to motion. - \\(k\\) is the spring constant, representing restoring force. - \\(F_0\\) is the external driving amplitude. - \\(\\omega\\) is the driving frequency. \ud83d\udd2c Types of Damping Underdamping ( \\(b^2<4mk\\) ): System oscillates with decreasing amplitude over time. Critical damping ( \\(b^2=4mk\\) ): System returns to equilibrium as fast as possible without oscillating. Overdamping ( \\(b^2>4mk\\) ): System slowly returns to equilibrium without oscillation. The quality factor \\(Q\\) measures how underdamped a system is: \\[Q=\\frac{m\\omega_0}{b}\\] where \\(\\omega_0=\\sqrt{k/m}\\) is the natural frequency. High \\(Q\\) means low damping and more oscillations. \ud83d\udcc8 2.2 Influence of Driving Amplitude When the system is driven externally, the steady-state amplitude follows: \\[A=\\frac{F_0/m}{\\sqrt{(\\omega_0^2-\\omega^2)^2+(b\\omega/m)^2}}\\] Small \\(F_0\\) : Response is proportional to the force (linear behavior). At resonance ( \\(\\omega=\\omega_0\\) ): Amplitude reaches a peak. High \\(F_0\\) : Nonlinear effects and potential chaotic motion emerge. \ud83c\udfb6 2.3 Influence of Driving Frequency The system's response changes with frequency \\(\\omega\\) : - Low-frequency regime ( \\(\\omega\\ll\\omega_0\\) ): The system follows the driving force smoothly. - Near resonance ( \\(\\omega\\approx\\omega_0\\) ): Maximum amplitude occurs due to resonance. - High-frequency regime ( \\(\\omega\\gg\\omega_0\\) ): The system cannot keep up with the driving force, resulting in reduced response. The phase lag \\(\\phi\\) between the driving force and displacement is: \\[\\tan\\phi=\\frac{b\\omega}{m(\\omega_0^2-\\omega^2)}\\] \ud83d\udd00 2.4 Transition Between Regular and Chaotic Motion For nonlinear driven systems, such as the Duffing oscillator: \\[m\\ddot{x} + b\\dot{x} + kx + \\alpha x^3 = F_0\\cos(\\omega t)\\] where \\(\\alpha\\) introduces nonlinearity. The system can exhibit: - Periodic motion : Regular oscillations with predictable behavior. - Quasiperiodic motion : Oscillations with multiple incommensurate frequencies. - Chaotic motion : Unpredictable behavior with extreme sensitivity to initial conditions. \ud83d\udcca Lyapunov Exponent A key indicator of chaos is the Lyapunov exponent \\(\\lambda\\) : \\[\\lambda=\\lim_{t\\to\\infty} \\frac{1}{t} \\ln \\frac{|\\delta x(t)|}{|\\delta x(0)|}\\] If \\(\\lambda>0\\) , the system is chaotic . If \\(\\lambda<0\\) , the system is stable and predictable . \ud83c\udf00 Poincar\u00e9 Section A visualization technique for chaos: - Regular motion forms closed loops. - Chaotic motion forms scattered, fractal-like structures. \ud83c\udf0d 2.5 Physical Significance \ud83d\ude97 Engineering: Used in shock absorbers and mechanical resonance analysis. \ud83c\udf26\ufe0f Climate Models: Helps predict weather patterns and turbulence. \ud83e\udde0 Biological Systems: Found in heart rhythms and neural oscillations. \ud83e\ude90 Astronomy: Governs planetary motion, stability, and celestial mechanics. \ud83d\udcdd Summary The behavior of oscillatory systems depends on damping, driving force, and frequency. Resonance amplifies oscillations but can also lead to instability. Nonlinearities introduce complex behaviors, including chaos. Chaos is characterized by sensitivity to initial conditions, analyzed via Lyapunov exponents and Poincare sections. This document provides a detailed mathematical and conceptual framework for analyzing dynamical systems, emphasizing the transition from order to chaos . \ud83d\udd2c Practical Applications of Oscillatory Systems \u2699\ufe0f Oscillatory systems play a crucial role in various engineering and scientific disciplines, governing the behavior of mechanical structures, electrical circuits, and energy harvesting technologies. By understanding these systems, engineers can design safer bridges, efficient energy systems, and optimized electronic devices. This section explores some key real-world applications, including energy harvesting, suspension bridges, and oscillating circuits. \u26a1 1. Energy Harvesting Energy harvesting technologies utilize oscillatory and vibrational motions to generate electrical energy from ambient sources such as vibrations, thermal fluctuations, or mechanical motion. These systems often employ piezoelectric, electromagnetic, or electrostatic transduction mechanisms. The governing equation for a simple electromechanical energy harvester is given by: \\[m\\ddot{x}+c\\dot{x}+kx=F_{ext}(t)\\] where: - \\(m\\) is the mass of the oscillating system, - \\(c\\) is the damping coefficient, - \\(k\\) is the stiffness constant, - \\(F_{ext}(t)\\) represents the external excitation force. By incorporating an electromechanical coupling term, the output voltage \\(V\\) across a piezoelectric material is given by: \\[V=\\frac{d_{31}F_{ext}(t)}{C_p}\\] where: - \\(d_{31}\\) is the piezoelectric charge constant, - \\(C_p\\) is the capacitance of the piezoelectric element. Applications: Powering remote sensors in industrial and environmental monitoring. Harvesting kinetic energy from human motion for wearable electronics. Utilizing ocean wave energy for renewable power generation. \ud83c\udf09 2. Suspension Bridges Suspension bridges are subject to oscillatory forces from wind, traffic loads, and seismic activity. The famous case of the Tacoma Narrows Bridge collapse in 1940 illustrates the importance of understanding resonance effects in structural engineering. The equation governing small oscillations of a bridge modeled as a beam is: \\[EI\\frac{\\partial^4 y}{\\partial x^4}+m\\frac{\\partial^2 y}{\\partial t^2}+c\\frac{\\partial y}{\\partial t}=F_{wind}(t)\\] where: - \\(E\\) is Young\u2019s modulus (material stiffness), - \\(I\\) is the second moment of area (beam shape factor), - \\(m\\) is the mass per unit length, - \\(c\\) is the damping coefficient, - \\(F_{wind}(t)\\) represents wind-induced forcing. For stability, damping must be introduced to prevent resonance when the natural frequency \\(\\omega_n\\) matches the forcing frequency: \\[\\omega_n=\\sqrt{\\frac{k}{m}}\\] Applications: - Design of earthquake-resistant bridges. - Optimization of bridge materials to reduce vibration amplitudes. - Wind tunnel testing for aerodynamically stable structures. \ud83d\udd0c 3. Oscillating Circuits Electrical circuits containing inductors, capacitors, and resistors exhibit oscillatory behavior essential in communication systems, signal processing, and power electronics. The standard RLC circuit equation follows from Kirchhoff\u2019s voltage law: \\[L\\frac{d^2 q}{d t^2}+R\\frac{d q}{d t}+\\frac{q}{C}=0\\] where: - \\(L\\) is the inductance, - \\(R\\) is the resistance, - \\(C\\) is the capacitance, - \\(q\\) is the charge on the capacitor. The characteristic equation of the circuit is: \\[s^2+\\frac{R}{L}s+\\frac{1}{LC}=0\\] Solving for \\(s\\) , the damping factor \\(\\zeta\\) determines whether the circuit is overdamped, underdamped, or critically damped: \\[\\zeta=\\frac{R}{2}\\sqrt{\\frac{C}{L}}\\] Applications: - Design of radio frequency (RF) filters in communication devices. - Stability analysis of power supply circuits. - Development of resonant transformers and wireless charging systems. \ud83c\udfc6 Summary Oscillatory systems are fundamental to many engineering applications, from structural mechanics to electronic circuit design and renewable energy solutions. Understanding their behavior through mathematical modeling allows for the optimization of structures and devices ,ensuring: \u2705 Stability against external perturbations. \u2705 Efficiency in energy conversion processes. \u2705 Performance improvement in electronic and mechanical systems. By mastering the principles of oscillatory dynamics, engineers and scientists can develop safer, more efficient, and innovative solutions to real-world challenges. Python/ plot import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the pendulum parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) m = 1.0 # Mass (kg) F0 = 1.5 # Driving force amplitude omega = 2.0 # Driving frequency # Define the equation of motion def forced_damped_pendulum(t, y, gamma, omega_0, f, omega): theta, omega_theta = y dydt = [ omega_theta, -gamma * omega_theta - omega_0**2 * np.sin(theta) + f * np.cos(omega * t) ] return dydt # Time span and initial conditions t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [np.pi / 4, 0] # Initial angle and velocity # Define damping cases damping_cases = { \"Underdamped\": 0.5, \"Critically Damped\": 2.0, \"Overdamped\": 5.0 } # Solve and plot for each case plt.figure(figsize=(12, 8)) for i, (label, gamma) in enumerate(damping_cases.items(), 1): omega_0 = np.sqrt(g / L) f = F0 / (m * L) sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega_0, f, omega)) # Extract solutions theta, omega_theta = sol.y # Phase diagram plt.subplot(1, 3, i) plt.plot(theta, omega_theta, label=label) plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(f\"Phase Diagram ({label})\") plt.legend() plt.grid() plt.tight_layout() plt.show() link: colab","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation-of-the-forced-damped-pendulum","text":"","title":"\ud83d\udcda Theoretical Foundation of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-formulating-the-differential-equation-for-the-forced-damped-pendulum","text":"The motion of a forced damped pendulum can be described using Newton's Second Law: \\[mL\\frac{d^2\\theta}{dt^2}+b\\frac{d\\theta}{dt}+mg\\sin\\theta=F_0\\cos(\\omega t)\\] where: - \\(m\\) is the mass of the pendulum, - \\(L\\) is the length of the pendulum, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(F_0\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency, - \\(\\theta\\) is the angular displacement. Dividing through by \\(mL\\) : \\[\\frac{d^2\\theta}{dt^2}+\\frac{b}{mL}\\frac{d\\theta}{dt}+\\frac{g}{L}\\sin\\theta=\\frac{F_0}{mL}\\cos(\\omega t)\\] To make the equation more manageable, we define dimensionless parameters: - \\(\\gamma=\\frac{b}{mL}\\) (damping ratio, representing the effect of friction), - \\(\\omega_0^2=\\frac{g}{L}\\) (square of the natural frequency, characterizing the system's oscillation rate), - \\(f=\\frac{F_0}{mL}\\) (scaled external force). This leads to the simplified equation: \\[\\ddot{\\theta}+\\gamma\\dot{\\theta}+\\omega_0^2\\sin\\theta=f\\cos(\\omega t)\\]","title":"1\ufe0f\u20e3 Formulating the Differential Equation for the Forced Damped Pendulum \u2696\ufe0f"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-approximate-solutions-for-small-angle-oscillations","text":"For small angles ( \\(\\theta\\approx\\sin\\theta\\) ), we can linearize the equation: \\[\\ddot{\\theta}+\\gamma\\dot{\\theta}+\\omega_0^2\\theta=f\\cos(\\omega t)\\] This equation describes a damped, driven harmonic oscillator . Using the method of undetermined coefficients, we assume the steady-state solution is of the form: \\[\\theta(t)=A\\cos(\\omega t-\\delta)\\] where: Amplitude \\(A\\) determines the system's response to the driving force: \\( \\(A=\\frac{f}{\\sqrt{(\\omega_0^2-\\omega^2)^2+\\gamma^2\\omega^2}}\\) \\) Phase shift \\(\\delta\\) accounts for the lag due to damping: \\( \\(\\tan\\delta=\\frac{\\gamma\\omega}{\\omega_0^2-\\omega^2}\\) \\) This means the oscillations lag behind the external force , with the delay increasing as damping grows.","title":"2\ufe0f\u20e3 Approximate Solutions for Small-Angle Oscillations \ud83d\udd2c"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-analysis-of-resonance-conditions-and-energy-impact","text":"","title":"3\ufe0f\u20e3 Analysis of Resonance Conditions and Energy Impact \ud83c\udfb5\u26a1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-when-the-system-responds-most-strongly","text":"Resonance occurs when the driving frequency matches the system's natural frequency: \\[\\omega\\approx\\omega_0\\] At this point, the denominator of \\(A\\) approaches zero, leading to a large increase in oscillation amplitude . In real-world systems, damping prevents infinite amplitude but still allows significant oscillations.","title":"\ud83c\udf1f Resonance: When the System Responds Most Strongly"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-considerations","text":"The total mechanical energy of the pendulum consists of kinetic and potential energy: \\[E=T+U=\\frac{1}{2}mL^2\\dot{\\theta}^2+mgL(1-\\cos\\theta)\\] For small oscillations, this simplifies to: \\[E\\approx\\frac{1}{2}mL^2\\dot{\\theta}^2+\\frac{1}{2}mgL\\theta^2\\] Under steady-state forced oscillations, energy input from the external force balances the dissipation due to damping. This results in a periodic exchange of energy within the system.","title":"\ud83d\udd0b Energy Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"The forced damped pendulum obeys a nonlinear differential equation, which simplifies under small-angle assumptions. Its behavior is characterized by damping, external driving forces, and resonance effects. Resonance occurs when the driving frequency approaches the natural frequency, leading to large oscillations. The system's energy oscillates due to an external force counteracting damping losses. These principles are crucial in engineering, physics, and even biological systems (e.g., heart rhythms, bridges swaying). Understanding them helps in designing stable and efficient mechanical systems! \ud83d\ude80","title":"\ud83d\udccc Summary \ud83d\udcdd"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"","title":"\ud83d\udd0d Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-influence-of-damping-coefficient","text":"The equation of motion for a damped driven system is given by: \\[m\\ddot{x} + b\\dot{x} + kx = F_0\\cos(\\omega t)\\] where: - \\(m\\) is the mass of the system, determining inertia. - \\(b\\) is the damping coefficient, controlling resistance to motion. - \\(k\\) is the spring constant, representing restoring force. - \\(F_0\\) is the external driving amplitude. - \\(\\omega\\) is the driving frequency.","title":"\u2696\ufe0f 2.1 Influence of Damping Coefficient"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#types-of-damping","text":"Underdamping ( \\(b^2<4mk\\) ): System oscillates with decreasing amplitude over time. Critical damping ( \\(b^2=4mk\\) ): System returns to equilibrium as fast as possible without oscillating. Overdamping ( \\(b^2>4mk\\) ): System slowly returns to equilibrium without oscillation. The quality factor \\(Q\\) measures how underdamped a system is: \\[Q=\\frac{m\\omega_0}{b}\\] where \\(\\omega_0=\\sqrt{k/m}\\) is the natural frequency. High \\(Q\\) means low damping and more oscillations.","title":"\ud83d\udd2c Types of Damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-influence-of-driving-amplitude","text":"When the system is driven externally, the steady-state amplitude follows: \\[A=\\frac{F_0/m}{\\sqrt{(\\omega_0^2-\\omega^2)^2+(b\\omega/m)^2}}\\] Small \\(F_0\\) : Response is proportional to the force (linear behavior). At resonance ( \\(\\omega=\\omega_0\\) ): Amplitude reaches a peak. High \\(F_0\\) : Nonlinear effects and potential chaotic motion emerge.","title":"\ud83d\udcc8 2.2 Influence of Driving Amplitude"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#23-influence-of-driving-frequency","text":"The system's response changes with frequency \\(\\omega\\) : - Low-frequency regime ( \\(\\omega\\ll\\omega_0\\) ): The system follows the driving force smoothly. - Near resonance ( \\(\\omega\\approx\\omega_0\\) ): Maximum amplitude occurs due to resonance. - High-frequency regime ( \\(\\omega\\gg\\omega_0\\) ): The system cannot keep up with the driving force, resulting in reduced response. The phase lag \\(\\phi\\) between the driving force and displacement is: \\[\\tan\\phi=\\frac{b\\omega}{m(\\omega_0^2-\\omega^2)}\\]","title":"\ud83c\udfb6 2.3 Influence of Driving Frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#24-transition-between-regular-and-chaotic-motion","text":"For nonlinear driven systems, such as the Duffing oscillator: \\[m\\ddot{x} + b\\dot{x} + kx + \\alpha x^3 = F_0\\cos(\\omega t)\\] where \\(\\alpha\\) introduces nonlinearity. The system can exhibit: - Periodic motion : Regular oscillations with predictable behavior. - Quasiperiodic motion : Oscillations with multiple incommensurate frequencies. - Chaotic motion : Unpredictable behavior with extreme sensitivity to initial conditions.","title":"\ud83d\udd00 2.4 Transition Between Regular and Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#lyapunov-exponent","text":"A key indicator of chaos is the Lyapunov exponent \\(\\lambda\\) : \\[\\lambda=\\lim_{t\\to\\infty} \\frac{1}{t} \\ln \\frac{|\\delta x(t)|}{|\\delta x(0)|}\\] If \\(\\lambda>0\\) , the system is chaotic . If \\(\\lambda<0\\) , the system is stable and predictable .","title":"\ud83d\udcca Lyapunov Exponent"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section","text":"A visualization technique for chaos: - Regular motion forms closed loops. - Chaotic motion forms scattered, fractal-like structures.","title":"\ud83c\udf00 Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#25-physical-significance","text":"\ud83d\ude97 Engineering: Used in shock absorbers and mechanical resonance analysis. \ud83c\udf26\ufe0f Climate Models: Helps predict weather patterns and turbulence. \ud83e\udde0 Biological Systems: Found in heart rhythms and neural oscillations. \ud83e\ude90 Astronomy: Governs planetary motion, stability, and celestial mechanics.","title":"\ud83c\udf0d 2.5 Physical Significance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary_1","text":"The behavior of oscillatory systems depends on damping, driving force, and frequency. Resonance amplifies oscillations but can also lead to instability. Nonlinearities introduce complex behaviors, including chaos. Chaos is characterized by sensitivity to initial conditions, analyzed via Lyapunov exponents and Poincare sections. This document provides a detailed mathematical and conceptual framework for analyzing dynamical systems, emphasizing the transition from order to chaos .","title":"\ud83d\udcdd Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications-of-oscillatory-systems","text":"Oscillatory systems play a crucial role in various engineering and scientific disciplines, governing the behavior of mechanical structures, electrical circuits, and energy harvesting technologies. By understanding these systems, engineers can design safer bridges, efficient energy systems, and optimized electronic devices. This section explores some key real-world applications, including energy harvesting, suspension bridges, and oscillating circuits.","title":"\ud83d\udd2c Practical Applications of Oscillatory Systems \u2699\ufe0f"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting","text":"Energy harvesting technologies utilize oscillatory and vibrational motions to generate electrical energy from ambient sources such as vibrations, thermal fluctuations, or mechanical motion. These systems often employ piezoelectric, electromagnetic, or electrostatic transduction mechanisms. The governing equation for a simple electromechanical energy harvester is given by: \\[m\\ddot{x}+c\\dot{x}+kx=F_{ext}(t)\\] where: - \\(m\\) is the mass of the oscillating system, - \\(c\\) is the damping coefficient, - \\(k\\) is the stiffness constant, - \\(F_{ext}(t)\\) represents the external excitation force. By incorporating an electromechanical coupling term, the output voltage \\(V\\) across a piezoelectric material is given by: \\[V=\\frac{d_{31}F_{ext}(t)}{C_p}\\] where: - \\(d_{31}\\) is the piezoelectric charge constant, - \\(C_p\\) is the capacitance of the piezoelectric element. Applications: Powering remote sensors in industrial and environmental monitoring. Harvesting kinetic energy from human motion for wearable electronics. Utilizing ocean wave energy for renewable power generation.","title":"\u26a1 1. Energy Harvesting"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges","text":"Suspension bridges are subject to oscillatory forces from wind, traffic loads, and seismic activity. The famous case of the Tacoma Narrows Bridge collapse in 1940 illustrates the importance of understanding resonance effects in structural engineering. The equation governing small oscillations of a bridge modeled as a beam is: \\[EI\\frac{\\partial^4 y}{\\partial x^4}+m\\frac{\\partial^2 y}{\\partial t^2}+c\\frac{\\partial y}{\\partial t}=F_{wind}(t)\\] where: - \\(E\\) is Young\u2019s modulus (material stiffness), - \\(I\\) is the second moment of area (beam shape factor), - \\(m\\) is the mass per unit length, - \\(c\\) is the damping coefficient, - \\(F_{wind}(t)\\) represents wind-induced forcing. For stability, damping must be introduced to prevent resonance when the natural frequency \\(\\omega_n\\) matches the forcing frequency: \\[\\omega_n=\\sqrt{\\frac{k}{m}}\\] Applications: - Design of earthquake-resistant bridges. - Optimization of bridge materials to reduce vibration amplitudes. - Wind tunnel testing for aerodynamically stable structures.","title":"\ud83c\udf09 2. Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-oscillating-circuits","text":"Electrical circuits containing inductors, capacitors, and resistors exhibit oscillatory behavior essential in communication systems, signal processing, and power electronics. The standard RLC circuit equation follows from Kirchhoff\u2019s voltage law: \\[L\\frac{d^2 q}{d t^2}+R\\frac{d q}{d t}+\\frac{q}{C}=0\\] where: - \\(L\\) is the inductance, - \\(R\\) is the resistance, - \\(C\\) is the capacitance, - \\(q\\) is the charge on the capacitor. The characteristic equation of the circuit is: \\[s^2+\\frac{R}{L}s+\\frac{1}{LC}=0\\] Solving for \\(s\\) , the damping factor \\(\\zeta\\) determines whether the circuit is overdamped, underdamped, or critically damped: \\[\\zeta=\\frac{R}{2}\\sqrt{\\frac{C}{L}}\\] Applications: - Design of radio frequency (RF) filters in communication devices. - Stability analysis of power supply circuits. - Development of resonant transformers and wireless charging systems.","title":"\ud83d\udd0c 3. Oscillating Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary_2","text":"Oscillatory systems are fundamental to many engineering applications, from structural mechanics to electronic circuit design and renewable energy solutions. Understanding their behavior through mathematical modeling allows for the optimization of structures and devices ,ensuring: \u2705 Stability against external perturbations. \u2705 Efficiency in energy conversion processes. \u2705 Performance improvement in electronic and mechanical systems. By mastering the principles of oscillatory dynamics, engineers and scientists can develop safer, more efficient, and innovative solutions to real-world challenges.","title":"\ud83c\udfc6 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-plot","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the pendulum parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) m = 1.0 # Mass (kg) F0 = 1.5 # Driving force amplitude omega = 2.0 # Driving frequency # Define the equation of motion def forced_damped_pendulum(t, y, gamma, omega_0, f, omega): theta, omega_theta = y dydt = [ omega_theta, -gamma * omega_theta - omega_0**2 * np.sin(theta) + f * np.cos(omega * t) ] return dydt # Time span and initial conditions t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [np.pi / 4, 0] # Initial angle and velocity # Define damping cases damping_cases = { \"Underdamped\": 0.5, \"Critically Damped\": 2.0, \"Overdamped\": 5.0 } # Solve and plot for each case plt.figure(figsize=(12, 8)) for i, (label, gamma) in enumerate(damping_cases.items(), 1): omega_0 = np.sqrt(g / L) f = F0 / (m * L) sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega_0, f, omega)) # Extract solutions theta, omega_theta = sol.y # Phase diagram plt.subplot(1, 3, i) plt.plot(theta, omega_theta, label=label) plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(f\"Phase Diagram ({label})\") plt.legend() plt.grid() plt.tight_layout() plt.show() link: colab","title":"Python/ plot"},{"location":"1%20Physics/2%20Gravity/%20/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its resulting motion is governed by classical mechanics and gravitational forces. Depending on its speed and direction at the moment of release, the payload may fall back to Earth, enter orbit, escape Earth\u2019s gravity, or follow a complex trajectory. This scenario blends concepts from Newtonian gravity and orbital mechanics, and is essential for space mission design and payload deployment. 1. Governing Physical Principles 1.1 Newton's Law of Universal Gravitation The gravitational force acting on a payload of mass \\(m\\) near Earth: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(G\\) is the gravitational constant: \\(6.67430 \\times 10^{-11} \\ \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}\\) - \\(M\\) is the mass of the Earth ( \\(5.972 \\times 10^{24}\\ \\text{kg}\\) ) - \\(r\\) is the distance from the center of the Earth to the payload From Newton's Second Law \\(F = ma\\) , the gravitational acceleration is: \\[ a = \\frac{F}{m} = \\frac{GM}{r^2} \\] This acceleration points toward the center of the Earth. 1.2 Total Mechanical Energy of the Payload The total energy \\(E\\) of the payload determines the type of trajectory: \\[ E = K + U = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\] Depending on \\(E\\) : - \\(E < 0\\) : Elliptical orbit - \\(E = 0\\) : Parabolic escape trajectory - \\(E > 0\\) : Hyperbolic escape trajectory \\[ E = K + U = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\] Depending on \\(E\\) : - \\(E < 0\\) : Elliptical orbit - \\(E = 0\\) : Parabolic escape trajectory - \\(E > 0\\) : Hyperbolic escape trajectory 1.3 Orbital Velocity Conditions Circular Orbit (First Cosmic Velocity) : \\( \\(v = \\sqrt{\\frac{GM}{r}}\\) \\) Escape Velocity (Second Cosmic Velocity) : \\( \\(v = \\sqrt{\\frac{2GM}{r}}\\) \\) If the initial speed is between these two values, the object follows an elliptical trajectory . 2. Numerical Simulation Approach We simulate the payload\u2019s trajectory using numerical integration of Newton\u2019s equations of motion: 2.1 Equations of Motion (in 2D) Let the position be \\(\\vec{r} = (x, y)\\) and velocity \\(\\vec{v} = (v_x, v_y)\\) . Acceleration due to gravity is: $$ \\vec{a} = -\\frac{GM}{r^3} \\vec{r} $$ Where \\(r = \\sqrt{x^2 + y^2}\\) and \\(\\vec{r} = (x, y)\\) . This gives a second-order ODE system: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}} \\] We convert this into a system of first-order ODEs for numerical integration. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Initial conditions altitude = 300e3 # altitude above Earth's surface (m) r0 = R_earth + altitude # initial distance from Earth's center (m) velocity_mag = 7500 # initial speed (m/s) theta = np.radians(30) # launch angle from horizontal (degrees to radians) # Initial position and velocity components x0 = r0 y0 = 0 vx0 = velocity_mag * np.cos(theta) vy0 = velocity_mag * np.sin(theta) # Time span for simulation t_span = (0, 10000) # seconds t_eval = np.linspace(t_span[0], t_span[1], 10000) # Define the system of ODEs def equations(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] # Initial state vector y_init = [x0, y0, vx0, vy0] # Solve the equations of motion solution = solve_ivp(equations, t_span, y_init, t_eval=t_eval, rtol=1e-8) # Extract solution x_vals = solution.y[0] y_vals = solution.y[1] r_vals = np.sqrt(x_vals**2 + y_vals**2) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(x_vals / 1e3, y_vals / 1e3, label='Payload Trajectory') # Draw Earth theta_circle = np.linspace(0, 2 * np.pi, 500) plt.plot(R_earth * np.cos(theta_circle) / 1e3, R_earth * np.sin(theta_circle) / 1e3, color='blue', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Trajectory of a Freely Released Payload') plt.axis('equal') plt.grid(True) plt.legend() plt.show() This Python code: Numerically solves the trajectory of an object released with a specific height, initial velocity, and angle, Under the influence of Earth's gravitational force (using Runge-Kutta with solve_ivp ), Graphically plots the trajectory, Displays the shape of the Earth as a circle (for comparison). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Sabitler G = 6.67430e-11 # Evrensel k\u00fctle\u00e7ekim sabiti (m^3/kg/s^2) M = 5.972e24 # D\u00fcnya'n\u0131n k\u00fctlesi (kg) R = 6.371e6 # D\u00fcnya'n\u0131n yar\u0131\u00e7ap\u0131 (m) # Ba\u015flang\u0131\u00e7 y\u00fcksekli\u011fi ve a\u00e7\u0131s\u0131 h = 300e3 # 300 km yukar\u0131dan b\u0131rak\u0131l\u0131yor r0 = R + h angle = np.radians(45) # f\u0131rlatma a\u00e7\u0131s\u0131 (dereceden radyana) # Farkl\u0131 h\u0131zlar (m/s cinsinden) initial_speeds = [6000, 7500, 11000] # Sim\u00fclasyon s\u00fcresi t_span = (0, 10000) t_eval = np.linspace(t_span[0], t_span[1], 10000) # Diferansiyel denklem sistemi def equations(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] # Y\u00f6r\u00fcnge \u00e7izimi plt.figure(figsize=(8, 8)) for v0 in initial_speeds: # Ba\u015flang\u0131\u00e7 vekt\u00f6r\u00fc vx0 = v0 * np.cos(angle) vy0 = v0 * np.sin(angle) y_init = [r0, 0, vx0, vy0] sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, rtol=1e-8) x_vals = sol.y[0] / 1e3 # km cinsine \u00e7evir y_vals = sol.y[1] / 1e3 plt.plot(x_vals, y_vals, label=f'v\u2080 = {v0/1000:.1f} km/s') # D\u00fcnya'n\u0131n \u00e7emberi theta = np.linspace(0, 2*np.pi, 500) plt.plot(R*np.cos(theta)/1e3, R*np.sin(theta)/1e3, color='blue', label='Earth') # Grafik ayarlar\u0131 plt.title('Payload Trajectories at Different Initial Velocities') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.axis('equal') plt.grid(True) plt.legend() plt.show() \ud83d\udef0\ufe0f Code Description \u2013 Payload Trajectories at Different Initial Velocities This Python script simulates and visualizes the trajectories of a payload released from 300 km above Earth with different initial speeds: \u2705 Key Features: Uses Newton\u2019s law of gravitation to model motion in 2D space. Simulates trajectories for three different initial velocities: 6000 m/s , 7500 m/s , and 11000 m/s . Integrates the equations of motion using solve_ivp (Runge-Kutta method). Plots each trajectory along with a circle representing Earth for comparison. \ud83d\udcca Goal: To show how initial velocity affects the type of trajectory: - Suborbital (falls back to Earth), - Orbital (remains in stable orbit), - Escape (leaves Earth\u2019s gravity). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from ipywidgets import interact, FloatSlider, IntSlider import matplotlib.patches as patches # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) # Equations of motion def equations(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] # Simulation function def simulate_trajectories(h=300e3, v0_1=7000, angle_1=45, v0_2=11000, angle_2=60, sim_time=10000): fig, ax = plt.subplots(figsize=(8, 8)) for v0, angle_deg, color, label in zip( [v0_1, v0_2], [angle_1, angle_2], ['orange', 'green'], ['Object 1', 'Object 2'] ): r0 = R + h theta = np.radians(angle_deg) x0, y0 = r0, 0 vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) y_init = [x0, y0, vx0, vy0] t_span = (0, sim_time) t_eval = np.linspace(*t_span, 10000) sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, rtol=1e-8) x_vals = sol.y[0] / 1e3 y_vals = sol.y[1] / 1e3 ax.plot(x_vals, y_vals, label=f'{label} (v\u2080={v0/1000:.1f} km/s, {angle_deg}\u00b0)', color=color) # Draw filled Earth earth = patches.Circle((0, 0), R / 1e3, color='blue') ax.add_patch(earth) ax.set_title('Payload Trajectories with Adjustable Parameters') ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.axis('equal') ax.grid(True) ax.legend() plt.show() # Interactive sliders interact( simulate_trajectories, h=FloatSlider(min=100e3, max=1000e3, step=50e3, value=300e3, description='Altitude (m)'), v0_1=FloatSlider(min=5000, max=12000, step=500, value=7000, description='v\u2080\u2081 (m/s)'), angle_1=IntSlider(min=0, max=90, step=5, value=45, description='Angle\u2081 (\u00b0)'), v0_2=FloatSlider(min=5000, max=12000, step=500, value=11000, description='v\u2080\u2082 (m/s)'), angle_2=IntSlider(min=0, max=90, step=5, value=60, description='Angle\u2082 (\u00b0)'), sim_time=IntSlider(min=5000, max=20000, step=1000, value=10000, description='Time (s)') ); link: colab ## \ud83d\udef0\ufe0f Code Explanation \u2013 Interactive Payload Trajectory Simulation This Python code simulates the motion of two payloads released near Earth with different initial velocities and angles. It demonstrates how their trajectories evolve under Earth\u2019s gravitational pull. \u2705 Key Features Uses Newton\u2019s law of gravity to compute motion in 2D space. Simulates and compares two different payloads. Lets you adjust: Altitude : Initial height above Earth. Initial speeds and angles : For both objects. Simulation time : Duration of the simulation. Uses ipywidgets sliders to make the parameters interactive. Visualizes: The curved paths (orbits/trajectories) of each payload. A filled blue circle representing Earth. \ud83d\udccc Goal To show how changing the initial velocity and direction affects whether the payload: - Falls back to Earth, - Enters orbit, - Escapes Earth\u2019s gravity. 3. Initial Conditions Let\u2019s assume the payload is released from a height \\(h\\) above Earth\u2019s surface with an initial velocity \\(v_0\\) at angle \\(\\theta\\) from the horizontal. Initial position: \\(x_0 = R_{\\oplus} + h\\) , \\(y_0 = 0\\) Initial velocity components: \\( \\(v_x = v_0 \\cos(\\theta)\\) \\) \\( \\(v_y = v_0 \\sin(\\theta)\\) \\) 4. Applications and Scenarios 4.1 Orbital Insertion If \\(v_0 \\approx \\sqrt{\\frac{GM}{R + h}}\\) , the payload can enter a circular or elliptical orbit. 4.2 Suborbital and Reentry If \\(v_0\\) is low, the trajectory will be parabolic or elliptical, eventually leading to reentry. 4.3 Escape Trajectory If \\(v_0 \\geq \\sqrt{\\frac{2GM}{R + h}}\\) , the payload escapes Earth\u2019s gravity. 5. Deliverables Python script that integrates the equations of motion for various initial conditions Visualizations of trajectories: reentry, orbital, and escape Energy calculations to classify the trajectory Analysis of velocity thresholds and angle dependence Note: The accompanying Python script uses the solve_ivp method from SciPy to integrate the motion equations, and Matplotlib to visualize the payload's path. (See Python code for numerical simulation and trajectory plots..)","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/%20/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/%20/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/%20/#motivation","text":"When a payload is released from a moving rocket near Earth, its resulting motion is governed by classical mechanics and gravitational forces. Depending on its speed and direction at the moment of release, the payload may fall back to Earth, enter orbit, escape Earth\u2019s gravity, or follow a complex trajectory. This scenario blends concepts from Newtonian gravity and orbital mechanics, and is essential for space mission design and payload deployment.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/%20/#1-governing-physical-principles","text":"","title":"1. Governing Physical Principles"},{"location":"1%20Physics/2%20Gravity/%20/#11-newtons-law-of-universal-gravitation","text":"The gravitational force acting on a payload of mass \\(m\\) near Earth: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(G\\) is the gravitational constant: \\(6.67430 \\times 10^{-11} \\ \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}\\) - \\(M\\) is the mass of the Earth ( \\(5.972 \\times 10^{24}\\ \\text{kg}\\) ) - \\(r\\) is the distance from the center of the Earth to the payload From Newton's Second Law \\(F = ma\\) , the gravitational acceleration is: \\[ a = \\frac{F}{m} = \\frac{GM}{r^2} \\] This acceleration points toward the center of the Earth.","title":"1.1 Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/%20/#12-total-mechanical-energy-of-the-payload","text":"The total energy \\(E\\) of the payload determines the type of trajectory: \\[ E = K + U = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\] Depending on \\(E\\) : - \\(E < 0\\) : Elliptical orbit - \\(E = 0\\) : Parabolic escape trajectory - \\(E > 0\\) : Hyperbolic escape trajectory \\[ E = K + U = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\] Depending on \\(E\\) : - \\(E < 0\\) : Elliptical orbit - \\(E = 0\\) : Parabolic escape trajectory - \\(E > 0\\) : Hyperbolic escape trajectory","title":"1.2 Total Mechanical Energy of the Payload"},{"location":"1%20Physics/2%20Gravity/%20/#13-orbital-velocity-conditions","text":"Circular Orbit (First Cosmic Velocity) : \\( \\(v = \\sqrt{\\frac{GM}{r}}\\) \\) Escape Velocity (Second Cosmic Velocity) : \\( \\(v = \\sqrt{\\frac{2GM}{r}}\\) \\) If the initial speed is between these two values, the object follows an elliptical trajectory .","title":"1.3 Orbital Velocity Conditions"},{"location":"1%20Physics/2%20Gravity/%20/#2-numerical-simulation-approach","text":"We simulate the payload\u2019s trajectory using numerical integration of Newton\u2019s equations of motion:","title":"2. Numerical Simulation Approach"},{"location":"1%20Physics/2%20Gravity/%20/#21-equations-of-motion-in-2d","text":"Let the position be \\(\\vec{r} = (x, y)\\) and velocity \\(\\vec{v} = (v_x, v_y)\\) . Acceleration due to gravity is: $$ \\vec{a} = -\\frac{GM}{r^3} \\vec{r} $$ Where \\(r = \\sqrt{x^2 + y^2}\\) and \\(\\vec{r} = (x, y)\\) . This gives a second-order ODE system: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}} \\] We convert this into a system of first-order ODEs for numerical integration. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Initial conditions altitude = 300e3 # altitude above Earth's surface (m) r0 = R_earth + altitude # initial distance from Earth's center (m) velocity_mag = 7500 # initial speed (m/s) theta = np.radians(30) # launch angle from horizontal (degrees to radians) # Initial position and velocity components x0 = r0 y0 = 0 vx0 = velocity_mag * np.cos(theta) vy0 = velocity_mag * np.sin(theta) # Time span for simulation t_span = (0, 10000) # seconds t_eval = np.linspace(t_span[0], t_span[1], 10000) # Define the system of ODEs def equations(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] # Initial state vector y_init = [x0, y0, vx0, vy0] # Solve the equations of motion solution = solve_ivp(equations, t_span, y_init, t_eval=t_eval, rtol=1e-8) # Extract solution x_vals = solution.y[0] y_vals = solution.y[1] r_vals = np.sqrt(x_vals**2 + y_vals**2) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(x_vals / 1e3, y_vals / 1e3, label='Payload Trajectory') # Draw Earth theta_circle = np.linspace(0, 2 * np.pi, 500) plt.plot(R_earth * np.cos(theta_circle) / 1e3, R_earth * np.sin(theta_circle) / 1e3, color='blue', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Trajectory of a Freely Released Payload') plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"2.1 Equations of Motion (in 2D)"},{"location":"1%20Physics/2%20Gravity/%20/#this-python-code","text":"Numerically solves the trajectory of an object released with a specific height, initial velocity, and angle, Under the influence of Earth's gravitational force (using Runge-Kutta with solve_ivp ), Graphically plots the trajectory, Displays the shape of the Earth as a circle (for comparison). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Sabitler G = 6.67430e-11 # Evrensel k\u00fctle\u00e7ekim sabiti (m^3/kg/s^2) M = 5.972e24 # D\u00fcnya'n\u0131n k\u00fctlesi (kg) R = 6.371e6 # D\u00fcnya'n\u0131n yar\u0131\u00e7ap\u0131 (m) # Ba\u015flang\u0131\u00e7 y\u00fcksekli\u011fi ve a\u00e7\u0131s\u0131 h = 300e3 # 300 km yukar\u0131dan b\u0131rak\u0131l\u0131yor r0 = R + h angle = np.radians(45) # f\u0131rlatma a\u00e7\u0131s\u0131 (dereceden radyana) # Farkl\u0131 h\u0131zlar (m/s cinsinden) initial_speeds = [6000, 7500, 11000] # Sim\u00fclasyon s\u00fcresi t_span = (0, 10000) t_eval = np.linspace(t_span[0], t_span[1], 10000) # Diferansiyel denklem sistemi def equations(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] # Y\u00f6r\u00fcnge \u00e7izimi plt.figure(figsize=(8, 8)) for v0 in initial_speeds: # Ba\u015flang\u0131\u00e7 vekt\u00f6r\u00fc vx0 = v0 * np.cos(angle) vy0 = v0 * np.sin(angle) y_init = [r0, 0, vx0, vy0] sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, rtol=1e-8) x_vals = sol.y[0] / 1e3 # km cinsine \u00e7evir y_vals = sol.y[1] / 1e3 plt.plot(x_vals, y_vals, label=f'v\u2080 = {v0/1000:.1f} km/s') # D\u00fcnya'n\u0131n \u00e7emberi theta = np.linspace(0, 2*np.pi, 500) plt.plot(R*np.cos(theta)/1e3, R*np.sin(theta)/1e3, color='blue', label='Earth') # Grafik ayarlar\u0131 plt.title('Payload Trajectories at Different Initial Velocities') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"This Python code:"},{"location":"1%20Physics/2%20Gravity/%20/#code-description-payload-trajectories-at-different-initial-velocities","text":"This Python script simulates and visualizes the trajectories of a payload released from 300 km above Earth with different initial speeds:","title":"\ud83d\udef0\ufe0f Code Description \u2013 Payload Trajectories at Different Initial Velocities"},{"location":"1%20Physics/2%20Gravity/%20/#key-features","text":"Uses Newton\u2019s law of gravitation to model motion in 2D space. Simulates trajectories for three different initial velocities: 6000 m/s , 7500 m/s , and 11000 m/s . Integrates the equations of motion using solve_ivp (Runge-Kutta method). Plots each trajectory along with a circle representing Earth for comparison.","title":"\u2705 Key Features:"},{"location":"1%20Physics/2%20Gravity/%20/#goal","text":"To show how initial velocity affects the type of trajectory: - Suborbital (falls back to Earth), - Orbital (remains in stable orbit), - Escape (leaves Earth\u2019s gravity). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from ipywidgets import interact, FloatSlider, IntSlider import matplotlib.patches as patches # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) # Equations of motion def equations(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] # Simulation function def simulate_trajectories(h=300e3, v0_1=7000, angle_1=45, v0_2=11000, angle_2=60, sim_time=10000): fig, ax = plt.subplots(figsize=(8, 8)) for v0, angle_deg, color, label in zip( [v0_1, v0_2], [angle_1, angle_2], ['orange', 'green'], ['Object 1', 'Object 2'] ): r0 = R + h theta = np.radians(angle_deg) x0, y0 = r0, 0 vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) y_init = [x0, y0, vx0, vy0] t_span = (0, sim_time) t_eval = np.linspace(*t_span, 10000) sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, rtol=1e-8) x_vals = sol.y[0] / 1e3 y_vals = sol.y[1] / 1e3 ax.plot(x_vals, y_vals, label=f'{label} (v\u2080={v0/1000:.1f} km/s, {angle_deg}\u00b0)', color=color) # Draw filled Earth earth = patches.Circle((0, 0), R / 1e3, color='blue') ax.add_patch(earth) ax.set_title('Payload Trajectories with Adjustable Parameters') ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.axis('equal') ax.grid(True) ax.legend() plt.show() # Interactive sliders interact( simulate_trajectories, h=FloatSlider(min=100e3, max=1000e3, step=50e3, value=300e3, description='Altitude (m)'), v0_1=FloatSlider(min=5000, max=12000, step=500, value=7000, description='v\u2080\u2081 (m/s)'), angle_1=IntSlider(min=0, max=90, step=5, value=45, description='Angle\u2081 (\u00b0)'), v0_2=FloatSlider(min=5000, max=12000, step=500, value=11000, description='v\u2080\u2082 (m/s)'), angle_2=IntSlider(min=0, max=90, step=5, value=60, description='Angle\u2082 (\u00b0)'), sim_time=IntSlider(min=5000, max=20000, step=1000, value=10000, description='Time (s)') ); link: colab ## \ud83d\udef0\ufe0f Code Explanation \u2013 Interactive Payload Trajectory Simulation This Python code simulates the motion of two payloads released near Earth with different initial velocities and angles. It demonstrates how their trajectories evolve under Earth\u2019s gravitational pull.","title":"\ud83d\udcca Goal:"},{"location":"1%20Physics/2%20Gravity/%20/#key-features_1","text":"Uses Newton\u2019s law of gravity to compute motion in 2D space. Simulates and compares two different payloads. Lets you adjust: Altitude : Initial height above Earth. Initial speeds and angles : For both objects. Simulation time : Duration of the simulation. Uses ipywidgets sliders to make the parameters interactive. Visualizes: The curved paths (orbits/trajectories) of each payload. A filled blue circle representing Earth.","title":"\u2705 Key Features"},{"location":"1%20Physics/2%20Gravity/%20/#goal_1","text":"To show how changing the initial velocity and direction affects whether the payload: - Falls back to Earth, - Enters orbit, - Escapes Earth\u2019s gravity.","title":"\ud83d\udccc Goal"},{"location":"1%20Physics/2%20Gravity/%20/#3-initial-conditions","text":"Let\u2019s assume the payload is released from a height \\(h\\) above Earth\u2019s surface with an initial velocity \\(v_0\\) at angle \\(\\theta\\) from the horizontal. Initial position: \\(x_0 = R_{\\oplus} + h\\) , \\(y_0 = 0\\) Initial velocity components: \\( \\(v_x = v_0 \\cos(\\theta)\\) \\) \\( \\(v_y = v_0 \\sin(\\theta)\\) \\)","title":"3. Initial Conditions"},{"location":"1%20Physics/2%20Gravity/%20/#4-applications-and-scenarios","text":"","title":"4. Applications and Scenarios"},{"location":"1%20Physics/2%20Gravity/%20/#41-orbital-insertion","text":"If \\(v_0 \\approx \\sqrt{\\frac{GM}{R + h}}\\) , the payload can enter a circular or elliptical orbit.","title":"4.1 Orbital Insertion"},{"location":"1%20Physics/2%20Gravity/%20/#42-suborbital-and-reentry","text":"If \\(v_0\\) is low, the trajectory will be parabolic or elliptical, eventually leading to reentry.","title":"4.2 Suborbital and Reentry"},{"location":"1%20Physics/2%20Gravity/%20/#43-escape-trajectory","text":"If \\(v_0 \\geq \\sqrt{\\frac{2GM}{R + h}}\\) , the payload escapes Earth\u2019s gravity.","title":"4.3 Escape Trajectory"},{"location":"1%20Physics/2%20Gravity/%20/#5-deliverables","text":"Python script that integrates the equations of motion for various initial conditions Visualizations of trajectories: reentry, orbital, and escape Energy calculations to classify the trajectory Analysis of velocity thresholds and angle dependence Note: The accompanying Python script uses the solve_ivp method from SciPy to integrate the motion equations, and Matplotlib to visualize the payload's path. (See Python code for numerical simulation and trajectory plots..)","title":"5. Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Derivation of the Relationship Between Orbital Period and Orbital Radius 1. Theoretical Derivation \ud83d\udcd8 \ud83d\udccc Introduction To understand the motion of celestial bodies, we derive the relationship between the square of the orbital period \\(T^2\\) and the cube of the orbital radius \\(r^3\\) for circular orbits . This relationship is a cornerstone of Kepler\u2019s Third Law , rooted in Newton\u2019s Law of Universal Gravitation and Circular Motion Dynamics . \ud83c\udf0c Newton's Law of Universal Gravitation Newton's law states that the gravitational force \\(F\\) between two masses \\(M\\) and \\(m\\) separated by a distance \\(r\\) is: \\[ F = G\\frac{Mm}{r^2} \\] Where: \\(F\\) is the gravitational force (N) \\(G\\) is the gravitational constant: \\(G \\approx 6.674 \\times 10^{-11} \\,\\text{Nm}^2/\\text{kg}^2\\) \\(M\\) is the mass of the central body (e.g., a planet or star) \\(m\\) is the mass of the orbiting object (e.g., a satellite) \\(r\\) is the orbital radius \ud83c\udfaf Centripetal Force for Circular Orbits An object in circular orbit requires a centripetal force to keep it in motion, given by: \\[ F_c = \\frac{mv^2}{r} \\] Where: \\(v\\) is the orbital speed \\(m\\) is the mass of the orbiting object \u2696\ufe0f Equating Gravitational and Centripetal Force Since the gravitational force provides the necessary centripetal force: \\[ \\frac{mv^2}{r} = G\\frac{Mm}{r^2} \\] Cancel \\(m\\) on both sides: \\[ \\frac{v^2}{r} = G\\frac{M}{r^2} \\] Multiply both sides by \\(r\\) : \\[ v^2 = \\frac{GM}{r} \\] \ud83d\udd01 Expressing Orbital Speed in Terms of Period The orbital period \\(T\\) is the time it takes to complete one full orbit. For circular motion: \\[ v = \\frac{2\\pi r}{T} \\] Substitute into the previous equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r} \\] Multiply both sides by \\(T^2\\) and then multiply both sides by \\(r\\) : \\[ 4\\pi^2 r^3 = GMT^2 \\] \ud83d\udd0d Solving for Orbital Period Rearrange to solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] \ud83d\udcd0 Kepler's Third Law (Mathematical Form) This is the mathematical form of Kepler\u2019s Third Law for circular orbits: \\[ T^2 \\propto r^3 \\] Where the proportionality constant is: \\[ \\frac{4\\pi^2}{GM} \\] This equation shows that for a small object orbiting a much more massive body, the square of its orbital period is proportional to the cube of the orbital radius. \ud83d\udcdd Notes This derivation assumes a circular orbit . For elliptical orbits, \\(r\\) becomes the semi-major axis \\(a\\) , but the form \\(T^2 \\propto a^3\\) still holds. This relationship is valid when \\(M \\gg m\\) , such as a satellite orbiting a planet or a planet orbiting the Sun. 2. Conceptual Discussion \ud83d\udd2d \ud83c\udf20 Significance of Kepler\u2019s Third Law in Astronomy and Astrophysics Kepler\u2019s Third Law, in its modern form, expresses a powerful connection between orbital mechanics and gravitational theory . The law states: \\[ T^2 \\propto r^3 \\] For two bodies in orbit, it implies that the square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis (orbital radius in the case of a circular orbit) \\(r\\) . This is significant because: It provides a universal relationship that holds across a vast range of scales, from artificial satellites to exoplanets and galaxies. It is derived from Newton\u2019s Law of Universal Gravitation , thereby linking observational astronomy to fundamental physics. It enables astronomers to infer invisible properties , such as the mass of distant stars , by observing orbital motions. \u2696\ufe0f Calculating the Mass of a Central Body By rearranging the Newtonian version of Kepler\u2019s Third Law: \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] We can solve for the mass \\(M\\) of the central object: \\[ M = \\frac{4\\pi^2}{G} \\cdot \\frac{r^3}{T^2} \\] Where: \\(M\\) is the mass of the central body (e.g., Sun, Earth, star), \\(r\\) is the orbital radius (or semi-major axis for elliptical orbits), \\(T\\) is the orbital period of the orbiting object. Applications : Measuring the mass of the Sun from Earth\u2019s orbit Estimating the mass of exoplanets by observing their effects on their host stars Determining the mass of galaxies using stellar orbits \ud83d\udccf Calculating Orbital Distances Rearranging the same equation, one can solve for \\(r\\) (orbital radius or semi-major axis) if \\(T\\) and \\(M\\) are known: \\[ r = \\left( \\frac{GMT^2}{4\\pi^2} \\right)^{1/3} \\] This is especially useful in: Determining the distance of moons from planets Estimating the orbit size of a satellite given its period Modeling the layout of planetary systems \ud83c\udf00 Extension to Elliptical Orbits Kepler originally stated his laws in terms of elliptical orbits. The modern form of the third law applies not just to circular motion but also to elliptical motion , with \\(r\\) replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{G(M + m)}a^3 \\] Where: \\(a\\) is the semi-major axis of the elliptical orbit \\(m\\) is the mass of the orbiting object (retained here if comparable to \\(M\\) ) In many practical cases where \\(M \\gg m\\) , the term \\(m\\) can be neglected, simplifying back to: \\[ T^2 = \\frac{4\\pi^2}{GM}a^3 \\] This generalization allows: Accurate modeling of planetary orbits in the Solar System Simulation of binary star systems Determination of orbital elements for comets and asteroids \ud83d\udcda Summary Kepler\u2019s Third Law is more than a geometric curiosity\u2014it\u2019s a dynamic, predictive tool that reveals hidden truths about the universe: It connects period , distance , and mass in a simple equation It underpins everything from spacecraft navigation to galactic astronomy It remains valid in both idealized circular and realistic elliptical orbits Its continued relevance shows the power of mathematics and observation working hand-in-hand to uncover the mechanisms of the cosmos. 3. Real-World Applications \ud83c\udf0d\ud83e\ude90 \ud83c\udf15 The Moon\u2019s Orbit Around Earth Let us analyze the Moon's orbit using Kepler\u2019s Third Law and compare theoretical predictions with empirical observations. Known Data Orbital period of Moon: \\(T = 27.32 \\, \\text{days} = 2.3606 \\times 10^6 \\, \\text{s}\\) Average orbital radius: \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) Gravitational constant: \\(G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) Mass of Earth: \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) Theoretical Check via Kepler\u2019s Law Using: \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] Plug in values: \\[ T^2 = \\frac{4\\pi^2}{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})}(3.844 \\times 10^8)^3 \\] Solving numerically: \\[ T^2 \\approx 5.57 \\times 10^{12} \\Rightarrow T \\approx 2.36 \\times 10^6 \\, \\text{s} \\] \u2705 Matches observed value within acceptable error bounds. \ud83e\ude90 Planetary Orbits in the Solar System Kepler\u2019s Law can also be used to compare planetary orbits with observed values. General Relation for Planets (Circular Approximation) \\[ \\frac{T_1^2}{r_1^3} = \\frac{T_2^2}{r_2^3} \\] Where \\(T\\) is the orbital period and \\(r\\) is the orbital radius (semi-major axis). Example: Earth vs. Mars Planet \\(T\\) (years) \\(r\\) (AU) Earth 1.00 1.00 Mars 1.88 1.52 Check the Ratio Left side (Earth): \\(\\frac{1.00^2}{1.00^3} = 1.00\\) Right side (Mars): \\(\\frac{1.88^2}{1.52^3} \\approx \\frac{3.53}{3.51} \\approx 1.00\\) \u2705 Confirms Kepler\u2019s Law \ud83d\udcca Empirical Data vs. Prediction Let\u2019s look at a summary comparison: Planet Observed \\(T\\) (years) Observed \\(r\\) (AU) \\(\\frac{T^2}{r^3}\\) Mercury 0.24 0.39 \\(\\approx 1.01\\) Venus 0.62 0.72 \\(\\approx 1.01\\) Earth 1.00 1.00 \\(1.00\\) Mars 1.88 1.52 \\(\\approx 1.00\\) Jupiter 11.86 5.20 \\(\\approx 1.00\\) Saturn 29.46 9.54 \\(\\approx 1.00\\) Interpretation The ratio \\(\\frac{T^2}{r^3}\\) remains approximately constant for all planets. Small deviations are due to orbital eccentricity , mass of the orbiting object , and non-ideal conditions . \ud83d\udccc Conclusion Kepler\u2019s Third Law: Accurately predicts orbital periods based on distance for natural satellites and planets . Is confirmed by empirical astronomical data across the Solar System. Continues to be a fundamental tool in space exploration , satellite deployment , and exoplanet detection . Next step? Implement this with code and graphs using real planetary datasets. Just say the word! \ud83d\ude80 Python/plot # Orbital simulation and Kepler's Third Law verification import numpy as np import matplotlib.pyplot as plt from scipy.constants import G from math import pi # --- Adjustable Parameters --- M_central = 5.972e24 # Central mass (e.g., Earth) in kg m_orbiting = 1000 # Orbiting body mass in kg (not used in Kepler's law) radii = np.linspace(1e7, 5e7, 10) # Orbital radii in meters # --- Calculate orbital period for each radius --- def orbital_period(radius, M): return 2 * pi * np.sqrt(radius**3 / (G * M)) periods = np.array([orbital_period(r, M_central) for r in radii]) # --- Kepler's Third Law Check: T\u00b2 \u221d r\u00b3 --- T_squared = periods**2 r_cubed = radii**3 # --- Plotting --- plt.figure(figsize=(12, 5)) # Orbital path example plt.subplot(1, 2, 1) theta = np.linspace(0, 2*pi, 100) r_example = 3e7 x = r_example * np.cos(theta) y = r_example * np.sin(theta) plt.plot(x, y) plt.plot(0, 0, 'yo', label='Central Body') plt.title('Circular Orbit (Example)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.legend() # Kepler\u2019s Law Plot plt.subplot(1, 2, 2) plt.plot(r_cubed, T_squared, 'bo-') plt.title(\"Kepler's Third Law Verification\") plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.grid(True) plt.tight_layout() plt.show() Link: colab","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-the-relationship-between-orbital-period-and-orbital-radius","text":"","title":"Derivation of the Relationship Between Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"","title":"1. Theoretical Derivation \ud83d\udcd8"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"To understand the motion of celestial bodies, we derive the relationship between the square of the orbital period \\(T^2\\) and the cube of the orbital radius \\(r^3\\) for circular orbits . This relationship is a cornerstone of Kepler\u2019s Third Law , rooted in Newton\u2019s Law of Universal Gravitation and Circular Motion Dynamics .","title":"\ud83d\udccc Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-universal-gravitation","text":"Newton's law states that the gravitational force \\(F\\) between two masses \\(M\\) and \\(m\\) separated by a distance \\(r\\) is: \\[ F = G\\frac{Mm}{r^2} \\] Where: \\(F\\) is the gravitational force (N) \\(G\\) is the gravitational constant: \\(G \\approx 6.674 \\times 10^{-11} \\,\\text{Nm}^2/\\text{kg}^2\\) \\(M\\) is the mass of the central body (e.g., a planet or star) \\(m\\) is the mass of the orbiting object (e.g., a satellite) \\(r\\) is the orbital radius","title":"\ud83c\udf0c Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force-for-circular-orbits","text":"An object in circular orbit requires a centripetal force to keep it in motion, given by: \\[ F_c = \\frac{mv^2}{r} \\] Where: \\(v\\) is the orbital speed \\(m\\) is the mass of the orbiting object","title":"\ud83c\udfaf Centripetal Force for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#equating-gravitational-and-centripetal-force","text":"Since the gravitational force provides the necessary centripetal force: \\[ \\frac{mv^2}{r} = G\\frac{Mm}{r^2} \\] Cancel \\(m\\) on both sides: \\[ \\frac{v^2}{r} = G\\frac{M}{r^2} \\] Multiply both sides by \\(r\\) : \\[ v^2 = \\frac{GM}{r} \\]","title":"\u2696\ufe0f Equating Gravitational and Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#expressing-orbital-speed-in-terms-of-period","text":"The orbital period \\(T\\) is the time it takes to complete one full orbit. For circular motion: \\[ v = \\frac{2\\pi r}{T} \\] Substitute into the previous equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r} \\] Multiply both sides by \\(T^2\\) and then multiply both sides by \\(r\\) : \\[ 4\\pi^2 r^3 = GMT^2 \\]","title":"\ud83d\udd01 Expressing Orbital Speed in Terms of Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#solving-for-orbital-period","text":"Rearrange to solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\]","title":"\ud83d\udd0d Solving for Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-mathematical-form","text":"This is the mathematical form of Kepler\u2019s Third Law for circular orbits: \\[ T^2 \\propto r^3 \\] Where the proportionality constant is: \\[ \\frac{4\\pi^2}{GM} \\] This equation shows that for a small object orbiting a much more massive body, the square of its orbital period is proportional to the cube of the orbital radius.","title":"\ud83d\udcd0 Kepler's Third Law (Mathematical Form)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#notes","text":"This derivation assumes a circular orbit . For elliptical orbits, \\(r\\) becomes the semi-major axis \\(a\\) , but the form \\(T^2 \\propto a^3\\) still holds. This relationship is valid when \\(M \\gg m\\) , such as a satellite orbiting a planet or a planet orbiting the Sun.","title":"\ud83d\udcdd Notes"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-conceptual-discussion","text":"","title":"2. Conceptual Discussion \ud83d\udd2d"},{"location":"1%20Physics/2%20Gravity/Problem_1/#significance-of-keplers-third-law-in-astronomy-and-astrophysics","text":"Kepler\u2019s Third Law, in its modern form, expresses a powerful connection between orbital mechanics and gravitational theory . The law states: \\[ T^2 \\propto r^3 \\] For two bodies in orbit, it implies that the square of the orbital period \\(T\\) is proportional to the cube of the semi-major axis (orbital radius in the case of a circular orbit) \\(r\\) . This is significant because: It provides a universal relationship that holds across a vast range of scales, from artificial satellites to exoplanets and galaxies. It is derived from Newton\u2019s Law of Universal Gravitation , thereby linking observational astronomy to fundamental physics. It enables astronomers to infer invisible properties , such as the mass of distant stars , by observing orbital motions.","title":"\ud83c\udf20 Significance of Kepler\u2019s Third Law in Astronomy and Astrophysics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-the-mass-of-a-central-body","text":"By rearranging the Newtonian version of Kepler\u2019s Third Law: \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] We can solve for the mass \\(M\\) of the central object: \\[ M = \\frac{4\\pi^2}{G} \\cdot \\frac{r^3}{T^2} \\] Where: \\(M\\) is the mass of the central body (e.g., Sun, Earth, star), \\(r\\) is the orbital radius (or semi-major axis for elliptical orbits), \\(T\\) is the orbital period of the orbiting object. Applications : Measuring the mass of the Sun from Earth\u2019s orbit Estimating the mass of exoplanets by observing their effects on their host stars Determining the mass of galaxies using stellar orbits","title":"\u2696\ufe0f Calculating the Mass of a Central Body"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-orbital-distances","text":"Rearranging the same equation, one can solve for \\(r\\) (orbital radius or semi-major axis) if \\(T\\) and \\(M\\) are known: \\[ r = \\left( \\frac{GMT^2}{4\\pi^2} \\right)^{1/3} \\] This is especially useful in: Determining the distance of moons from planets Estimating the orbit size of a satellite given its period Modeling the layout of planetary systems","title":"\ud83d\udccf Calculating Orbital Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler originally stated his laws in terms of elliptical orbits. The modern form of the third law applies not just to circular motion but also to elliptical motion , with \\(r\\) replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{G(M + m)}a^3 \\] Where: \\(a\\) is the semi-major axis of the elliptical orbit \\(m\\) is the mass of the orbiting object (retained here if comparable to \\(M\\) ) In many practical cases where \\(M \\gg m\\) , the term \\(m\\) can be neglected, simplifying back to: \\[ T^2 = \\frac{4\\pi^2}{GM}a^3 \\] This generalization allows: Accurate modeling of planetary orbits in the Solar System Simulation of binary star systems Determination of orbital elements for comets and asteroids","title":"\ud83c\udf00 Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"Kepler\u2019s Third Law is more than a geometric curiosity\u2014it\u2019s a dynamic, predictive tool that reveals hidden truths about the universe: It connects period , distance , and mass in a simple equation It underpins everything from spacecraft navigation to galactic astronomy It remains valid in both idealized circular and realistic elliptical orbits Its continued relevance shows the power of mathematics and observation working hand-in-hand to uncover the mechanisms of the cosmos.","title":"\ud83d\udcda Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-applications","text":"","title":"3. Real-World Applications \ud83c\udf0d\ud83e\ude90"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-moons-orbit-around-earth","text":"Let us analyze the Moon's orbit using Kepler\u2019s Third Law and compare theoretical predictions with empirical observations.","title":"\ud83c\udf15 The Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#known-data","text":"Orbital period of Moon: \\(T = 27.32 \\, \\text{days} = 2.3606 \\times 10^6 \\, \\text{s}\\) Average orbital radius: \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) Gravitational constant: \\(G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) Mass of Earth: \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\)","title":"Known Data"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-check-via-keplers-law","text":"Using: \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] Plug in values: \\[ T^2 = \\frac{4\\pi^2}{(6.674 \\times 10^{-11})(5.972 \\times 10^{24})}(3.844 \\times 10^8)^3 \\] Solving numerically: \\[ T^2 \\approx 5.57 \\times 10^{12} \\Rightarrow T \\approx 2.36 \\times 10^6 \\, \\text{s} \\] \u2705 Matches observed value within acceptable error bounds.","title":"Theoretical Check via Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planetary-orbits-in-the-solar-system","text":"Kepler\u2019s Law can also be used to compare planetary orbits with observed values.","title":"\ud83e\ude90 Planetary Orbits in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#general-relation-for-planets-circular-approximation","text":"\\[ \\frac{T_1^2}{r_1^3} = \\frac{T_2^2}{r_2^3} \\] Where \\(T\\) is the orbital period and \\(r\\) is the orbital radius (semi-major axis).","title":"General Relation for Planets (Circular Approximation)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-earth-vs-mars","text":"Planet \\(T\\) (years) \\(r\\) (AU) Earth 1.00 1.00 Mars 1.88 1.52","title":"Example: Earth vs. Mars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#check-the-ratio","text":"Left side (Earth): \\(\\frac{1.00^2}{1.00^3} = 1.00\\) Right side (Mars): \\(\\frac{1.88^2}{1.52^3} \\approx \\frac{3.53}{3.51} \\approx 1.00\\) \u2705 Confirms Kepler\u2019s Law","title":"Check the Ratio"},{"location":"1%20Physics/2%20Gravity/Problem_1/#empirical-data-vs-prediction","text":"Let\u2019s look at a summary comparison: Planet Observed \\(T\\) (years) Observed \\(r\\) (AU) \\(\\frac{T^2}{r^3}\\) Mercury 0.24 0.39 \\(\\approx 1.01\\) Venus 0.62 0.72 \\(\\approx 1.01\\) Earth 1.00 1.00 \\(1.00\\) Mars 1.88 1.52 \\(\\approx 1.00\\) Jupiter 11.86 5.20 \\(\\approx 1.00\\) Saturn 29.46 9.54 \\(\\approx 1.00\\)","title":"\ud83d\udcca Empirical Data vs. Prediction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interpretation","text":"The ratio \\(\\frac{T^2}{r^3}\\) remains approximately constant for all planets. Small deviations are due to orbital eccentricity , mass of the orbiting object , and non-ideal conditions .","title":"Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law: Accurately predicts orbital periods based on distance for natural satellites and planets . Is confirmed by empirical astronomical data across the Solar System. Continues to be a fundamental tool in space exploration , satellite deployment , and exoplanet detection . Next step? Implement this with code and graphs using real planetary datasets. Just say the word! \ud83d\ude80","title":"\ud83d\udccc Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#pythonplot","text":"# Orbital simulation and Kepler's Third Law verification import numpy as np import matplotlib.pyplot as plt from scipy.constants import G from math import pi # --- Adjustable Parameters --- M_central = 5.972e24 # Central mass (e.g., Earth) in kg m_orbiting = 1000 # Orbiting body mass in kg (not used in Kepler's law) radii = np.linspace(1e7, 5e7, 10) # Orbital radii in meters # --- Calculate orbital period for each radius --- def orbital_period(radius, M): return 2 * pi * np.sqrt(radius**3 / (G * M)) periods = np.array([orbital_period(r, M_central) for r in radii]) # --- Kepler's Third Law Check: T\u00b2 \u221d r\u00b3 --- T_squared = periods**2 r_cubed = radii**3 # --- Plotting --- plt.figure(figsize=(12, 5)) # Orbital path example plt.subplot(1, 2, 1) theta = np.linspace(0, 2*pi, 100) r_example = 3e7 x = r_example * np.cos(theta) y = r_example * np.sin(theta) plt.plot(x, y) plt.plot(0, 0, 'yo', label='Central Body') plt.title('Circular Orbit (Example)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.legend() # Kepler\u2019s Law Plot plt.subplot(1, 2, 2) plt.plot(r_cubed, T_squared, 'bo-') plt.title(\"Kepler's Third Law Verification\") plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.grid(True) plt.tight_layout() plt.show() Link: colab","title":"Python/plot"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Definitions and Explanations In the context of classical mechanics and orbital dynamics, cosmic velocities refer to critical speeds associated with motion in a gravitational field. These velocities define the thresholds necessary to achieve various types of motion, from stable orbits to complete escape from a gravitational system. 1.1 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity , also known as the orbital velocity , is the minimum velocity an object must have to enter a stable circular orbit around a celestial body without additional propulsion. Mathematical Definition: This velocity is derived from the balance between gravitational force and centripetal force : \\[ F_\\text{gravity} = F_\\text{centripetal} \\] \\[ \\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\] Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(v_1\\) is the first cosmic velocity, - \\(G\\) is the universal gravitational constant ( \\(6.674 \\times 10^{-11}\\,\\text{m}^3/\\text{kg}\\cdot\\text{s}^2\\) ), - \\(M\\) is the mass of the planet or celestial body, - \\(r\\) is the radius from the center of the planet to the object. 1.2 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity , commonly referred to as escape velocity , is the minimum speed needed for an object to break free from the gravitational influence of a celestial body without further propulsion. Mathematical Definition: This velocity is derived from the conservation of energy principle: \\[ \\text{Kinetic Energy} + \\text{Potential Energy} = 0 \\] \\[ \\frac{1}{2}mv_2^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Alternatively: \\[ v_2 = \\sqrt{2}\\cdot v_1 \\] 1.3 Third Cosmic Velocity (Interstellar Escape Velocity) The third cosmic velocity is the minimum speed required to escape the gravitational influence of an entire star system (e.g., the Solar System), starting from a planet\u2019s surface. This includes overcoming both: 1. The gravitational pull of the planet , 2. The gravitational pull of the star (e.g., the Sun). Approximate Mathematical Expression: Let: - \\(v_{2,\\text{planet}}\\) : escape velocity from the planet - \\(v_{2,\\text{sun}}\\) : escape velocity from the Sun at the planet's orbital distance Then, the third cosmic velocity is approximately: \\[ v_3 = \\sqrt{v_{2,\\text{planet}}^2 + v_{2,\\text{sun}}^2} \\] A more detailed expression (from Earth's surface): \\[ v_3 = \\sqrt{2G\\left(\\frac{M_\\text{Earth}}{R_\\text{Earth}} + \\frac{M_\\text{Sun}}{d}\\right)} \\] Where: - \\(M_\\text{Earth}\\) and \\(R_\\text{Earth}\\) : Earth\u2019s mass and radius, - \\(M_\\text{Sun}\\) : Sun\u2019s mass, - \\(d\\) : distance from the Earth to the Sun. 1.4 Physical Interpretation and Differences Velocity Meaning Outcome Equation 1st Cosmic Velocity Minimum speed for stable circular orbit around a planet Orbit \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) 2nd Cosmic Velocity Minimum speed to escape a planet\u2019s gravity Leave the planet forever \\(v_2 = \\sqrt{\\frac{2GM}{r}}\\) 3rd Cosmic Velocity Minimum speed to escape the entire star system Leave the Solar System \\(v_3 = \\sqrt{v_{2,\\text{planet}}^2 + v_{2,\\text{sun}}^2}\\) Each of these velocities represents a critical threshold in mission design and trajectory planning in astrodynamics, from low-Earth orbits to interplanetary and interstellar travel. 2. Mathematical Analysis This section provides a rigorous derivation of the first, second, and third cosmic velocities using classical Newtonian mechanics. The parameters involved are identified and assumptions discussed. 2.1 First Cosmic Velocity \u2013 Orbital Velocity The first cosmic velocity is the speed at which an object must travel to maintain a stable circular orbit just above the surface of a celestial body, under the influence of gravity alone. Derivation: We equate the gravitational force to the centripetal force: \\[ F_\\text{gravity} = F_\\text{centripetal} \\] \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Canceling mass \\(m\\) and solving for \\(v\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Parameters: \\(G\\) : Gravitational constant ( \\(6.674 \\times 10^{-11}~\\text{m}^3/\\text{kg}\\cdot\\text{s}^2\\) ) \\(M\\) : Mass of the planet or celestial body \\(r\\) : Distance from the center of the planet to the object (typically, the planet\u2019s radius for low orbits) Assumptions: Circular orbit (eccentricity = 0) No air resistance Central mass is spherically symmetric and non-rotating 2.2 Second Cosmic Velocity \u2013 Escape Velocity The second cosmic velocity is the minimum speed needed for an object to escape the gravitational field of a planet, assuming no propulsion after the initial launch. Derivation: From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v\\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Or in terms of the first cosmic velocity: \\[ v_2 = \\sqrt{2} \\cdot v_1 \\] Parameters: Same as in first cosmic velocity Assumptions: No energy loss (e.g., due to drag or friction) No further propulsion during flight Planet's mass is much larger than the object's mass 2.3 Third Cosmic Velocity \u2013 Interstellar Escape Velocity The third cosmic velocity is the minimum speed required to escape the gravitational pull of both the Earth and the Sun \u2014 that is, to leave the Solar System entirely. This requires combining the escape velocity from Earth and the escape velocity from the Sun at Earth\u2019s orbital distance. Derivation: Let: - \\(v_{2,\\text{Earth}}\\) : escape velocity from Earth\u2019s surface - \\(v_{2,\\text{Sun}}\\) : escape velocity from the Sun at Earth\u2019s orbit Then, by energy conservation and vector addition (assuming aligned direction): \\[ v_3 = \\sqrt{v_{2,\\text{Earth}}^2 + v_{2,\\text{Sun}}^2} \\] Escape velocity from the Sun at Earth's orbit: \\[ v_{2,\\text{Sun}} = \\sqrt{\\frac{2GM_\\text{Sun}}{d}} \\] Where: - \\(M_\\text{Sun}\\) : mass of the Sun - \\(d\\) : distance from the Sun to the Earth ( \\(\\approx 1.496 \\times 10^{11}~\\text{m}\\) ) Then the third cosmic velocity becomes: \\[ v_3 = \\sqrt{ \\left( \\sqrt{\\frac{2GM_\\text{Earth}}{R_\\text{Earth}}} \\right)^2 + \\left( \\sqrt{\\frac{2GM_\\text{Sun}}{d}} \\right)^2 } \\] Which simplifies to: \\[ v_3 = \\sqrt{ \\frac{2GM_\\text{Earth}}{R_\\text{Earth}} + \\frac{2GM_\\text{Sun}}{d} } \\] Parameters: \\(M_\\text{Earth}\\) : mass of Earth \\(R_\\text{Earth}\\) : radius of Earth \\(M_\\text{Sun}\\) : mass of the Sun \\(d\\) : distance from Earth to Sun Assumptions: No significant gravitational interactions from other planets Trajectory is radial and direct (idealized) No propulsion after launch Newtonian mechanics (relativistic effects neglected) Summary Table Velocity Formula Depends On First Cosmic ( \\(v_1\\) ) \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) \\(M\\) , \\(r\\) Second Cosmic ( \\(v_2\\) ) \\(v_2 = \\sqrt{\\frac{2GM}{r}}\\) \\(M\\) , \\(r\\) Third Cosmic ( \\(v_3\\) ) \\(v_3 = \\sqrt{\\frac{2GM_\\text{Earth}}{R_\\text{Earth}} + \\frac{2GM_\\text{Sun}}{d}}\\) \\(M_\\text{Earth}\\) , \\(R_\\text{Earth}\\) , \\(M_\\text{Sun}\\) , \\(d\\) Planetary Velocity Calculations Introduction In orbital mechanics, the velocity of a planet in orbit around the Sun is critical for understanding its motion. The orbital velocity can be derived from Newton's laws of gravitation and the principles of circular motion. The orbital velocity \\(v\\) of a planet can be calculated using the following formula: \\[ v = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(v\\) is the orbital velocity, - \\(G\\) is the gravitational constant \\((6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2})\\) , - \\(M\\) is the mass of the Sun \\((1.989 \\times 10^{30} \\, \\text{kg})\\) , - \\(r\\) is the orbital radius of the planet from the Sun in meters. The orbital velocity can be broken down into three main categories: - Circular Orbital Velocity (constant orbit), - Escape Velocity (velocity required to escape the Sun\u2019s gravity), - Orbital Period (time taken to complete one orbit). We will use actual planetary data for the following planets: 1. Earth 2. Mars 3. Jupiter 1. Earth Orbital radius of Earth from the Sun: \\(r_{\\text{Earth}} = 1.496 \\times 10^{11} \\, \\text{m}\\) Orbital period of Earth: \\(T_{\\text{Earth}} = 365.25 \\, \\text{days}\\) Earth's Orbital Velocity: Using the orbital velocity formula: \\[ v_{\\text{Earth}} = \\sqrt{\\frac{GM_{\\text{Sun}}}{r_{\\text{Earth}}}} \\] Substitute the known values: \\[ v_{\\text{Earth}} = \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (1.989 \\times 10^{30})}{1.496 \\times 10^{11}}} \\] The result will give the orbital velocity in meters per second. 2. Mars Orbital radius of Mars from the Sun: \\(r_{\\text{Mars}} = 2.279 \\times 10^{11} \\, \\text{m}\\) Orbital period of Mars: \\(T_{\\text{Mars}} = 687 \\, \\text{days}\\) Mars' Orbital Velocity: Similar to Earth, using the orbital velocity formula: \\[ v_{\\text{Mars}} = \\sqrt{\\frac{GM_{\\text{Sun}}}{r_{\\text{Mars}}}} \\] Substitute the known values: \\[ v_{\\text{Mars}} = \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (1.989 \\times 10^{30})}{2.279 \\times 10^{11}}} \\] The result will give the orbital velocity of Mars in meters per second. 3. Jupiter Orbital radius of Jupiter from the Sun: \\(r_{\\text{Jupiter}} = 7.785 \\times 10^{11} \\, \\text{m}\\) Orbital period of Jupiter: \\(T_{\\text{Jupiter}} = 4333 \\, \\text{days}\\) Jupiter's Orbital Velocity: Again, using the orbital velocity formula: \\[ v_{\\text{Jupiter}} = \\sqrt{\\frac{GM_{\\text{Sun}}}{r_{\\text{Jupiter}}}} \\] Substitute the known values: \\[ v_{\\text{Jupiter}} = \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (1.989 \\times 10^{30})}{7.785 \\times 10^{11}}} \\] The result will give the orbital velocity of Jupiter in meters per second. Python Code Implementation import math # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun in kg # Function to calculate orbital velocity def orbital_velocity(r): return math.sqrt(G * M_sun / r) # Planetary data (in meters) r_earth = 1.496e11 # Orbital radius of Earth r_mars = 2.279e11 # Orbital radius of Mars r_jupiter = 7.785e11 # Orbital radius of Jupiter # Calculate velocities v_earth = orbital_velocity(r_earth) v_mars = orbital_velocity(r_mars) v_jupiter = orbital_velocity(r_jupiter) # Output results print(f\"Orbital velocity of Earth: {v_earth:.2f} m/s\") print(f\"Orbital velocity of Mars: {v_mars:.2f} m/s\") print(f\"Orbital velocity of Jupiter: {v_jupiter:.2f} m/s\") \ud83d\udcca Tabulated Results The table will look like this (values may vary slightly based on precision): Planet v\u2081 (Orbital) [km/s] v\u2082 (Escape) [km/s] v\u2083 (Solar Escape) [km/s] Earth ~7.91 ~11.18 ~42.1 Mars ~3.56 ~5.03 ~34.1 Jupiter ~42.1 ~59.5 ~87.3 \ud83d\udccc Notes These computations assume: Spherical symmetry No atmospheric drag Instantaneous velocity achieved (no thrust phase) \\(v_3\\) is approximate and assumes escape velocity from Sun calculated at the orbital distance of the planet. 4. Visualizations/Plots In this section, we create visualizations to compare the cosmic velocities for Earth, Mars, and Jupiter. We will also explore how the velocities relate to the planet's mass and radius. \ud83d\udcca Bar Chart: Cosmic Velocities for Earth, Mars, and Jupiter We will plot the first , second , and third cosmic velocities for each planet using bar charts for easy comparison. import matplotlib.pyplot as plt # Extracting data for plotting planets_names = ['Earth', 'Mars', 'Jupiter'] v1_values = [row['v1 (Orbital) [km/s]'] for _, row in df.iterrows()] v2_values = [row['v2 (Escape) [km/s]'] for _, row in df.iterrows()] v3_values = [row['v3 (Solar Escape) [km/s]'] for _, row in df.iterrows()] # Bar chart fig, ax = plt.subplots(figsize=(10, 6)) width = 0.25 # Bar width x = np.arange(len(planets_names)) # Create bars for each velocity type ax.bar(x - width, v1_values, width, label='First Cosmic Velocity') ax.bar(x, v2_values, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_values, width, label='Third Cosmic Velocity') # Formatting ax.set_xlabel('Planets') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(planets_names) ax.legend() plt.tight_layout() plt.show() \ud83c\udf0d Velocity vs. Planet Mass and Radius We will create two plots to investigate how the cosmic velocities vary with the planet's mass and radius . 1. Velocity vs. Planet Mass We will create two plots to investigate how the cosmic velocities vary with the 2. Velocity vs. Planet Radius \ud83c\udf10 Optional: 3D or Animation-Based Visuals for Conceptual Understanding For deeper understanding, we can visualize the velocities in 3D space or through animations . 1. 3D Plot of Cosmic Velocities 2. Animation of Planetary Escape \ud83d\udcc8 Final Thoughts - The bar charts and line plots offer a comparative view of cosmic velocities across different planets. 5. Application & Discussion \ud83d\ude80 1. Importance of Each Cosmic Velocity in Real-World Space Missions The concept of cosmic velocities plays a crucial role in modern space exploration. Understanding these velocities is essential for designing spacecraft and planning interplanetary or interstellar missions. Here we explore the significance of each cosmic velocity: 1.1 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the minimum speed required for an object to remain in a stable orbit around a planet or star. Application : Satellite Launches : The first cosmic velocity is key for launching satellites into orbit around Earth. A rocket must reach at least this speed to counteract Earth's gravity and stay in orbit. Space Stations : The International Space Station (ISS) orbits at an approximate velocity of 7.66 km/s, which is just slightly above Earth's first cosmic velocity. Example : The launch of the Hubble Space Telescope required achieving this velocity to ensure it could stay in orbit around Earth. 1.2 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum velocity required to escape a celestial body's gravitational influence. This is the speed needed for a spacecraft to break free from Earth\u2019s gravity without further propulsion. Application : Escape from Earth's Gravity : Spacecraft like the Apollo missions or the Mars rovers use this velocity to leave Earth\u2019s atmosphere and escape into interplanetary space. Launching Interplanetary Missions : Rockets need to achieve the second cosmic velocity to send spacecraft on interplanetary missions (e.g., to Mars or Jupiter). Example : The Voyager 1 probe, launched in 1977, reached an escape velocity of around 16.5 km/s, allowing it to break free from Earth\u2019s gravitational influence and begin its journey to interstellar space. 1.3 Third Cosmic Velocity (Solar System Escape Velocity) The third cosmic velocity is the velocity needed to escape not just a planet, but the entire solar system , including escaping the Sun\u2019s gravity. Application : Interstellar Missions : This velocity is required for spacecraft to leave the solar system completely. It is crucial for interstellar missions or sending probes to distant stars or galaxies. Escape from Solar System : Missions aiming to travel beyond the influence of the Sun\u2019s gravity need to achieve this velocity. Example : The Voyager 1 spacecraft achieved this velocity after escaping Earth\u2019s gravity, enabling it to travel toward the interstellar medium . Currently, it is the farthest human-made object from Earth. \ud83c\udf0c 2. Relating Cosmic Velocities to Historical and Planned Space Missions 2.1 Voyager Missions (Voyager 1 & 2) Voyager 1 , launched in 1977, and Voyager 2 , launched in 1977 as well, are key examples of space probes that have used the second and third cosmic velocities to escape Earth\u2019s gravity and the Sun's gravitational pull. Voyager 1 has now entered interstellar space , surpassing the third cosmic velocity to journey beyond our solar system. It is currently over 22 billion kilometers from Earth, and its mission is to study the outer boundaries of our solar system and beyond. 2.2 Artemis Program NASA\u2019s Artemis program , planned for the coming years, aims to send humans back to the Moon and eventually to Mars. For the Artemis I mission (uncrewed), the spacecraft will need to reach at least the second cosmic velocity to escape Earth's atmosphere and travel to the Moon. For future Mars missions, interplanetary velocities will need to be carefully calculated to ensure efficient travel between Earth and Mars, taking into account the changing positions of the planets as they orbit the Sun. 2.3 Mars Rover Missions NASA's Mars rovers , such as Curiosity and Perseverance , need to overcome Earth's gravity (second cosmic velocity) to reach Mars, and then use orbital velocities to safely enter Mars\u2019 atmosphere for landing. Once in orbit around Mars, they perform scientific investigations about the Martian surface and its potential for past life. \ud83c\udf20 3. Conclusion The understanding and application of the first , second , and third cosmic velocities are fundamental for planning space missions, from launching satellites into Earth orbit to sending probes into interstellar space. These velocities help scientists and engineers design spacecraft that can successfully complete their missions and overcome the gravitational challenges posed by celestial bodies. Space exploration will continue to rely on these principles to push the boundaries of our solar system and beyond, and understanding them is key to missions like Voyager , Artemis , and future interstellar travel.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-and-explanations","text":"In the context of classical mechanics and orbital dynamics, cosmic velocities refer to critical speeds associated with motion in a gravitational field. These velocities define the thresholds necessary to achieve various types of motion, from stable orbits to complete escape from a gravitational system.","title":"1. Definitions and Explanations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity , also known as the orbital velocity , is the minimum velocity an object must have to enter a stable circular orbit around a celestial body without additional propulsion.","title":"1.1 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-definition","text":"This velocity is derived from the balance between gravitational force and centripetal force : \\[ F_\\text{gravity} = F_\\text{centripetal} \\] \\[ \\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\] Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(v_1\\) is the first cosmic velocity, - \\(G\\) is the universal gravitational constant ( \\(6.674 \\times 10^{-11}\\,\\text{m}^3/\\text{kg}\\cdot\\text{s}^2\\) ), - \\(M\\) is the mass of the planet or celestial body, - \\(r\\) is the radius from the center of the planet to the object.","title":"Mathematical Definition:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity , commonly referred to as escape velocity , is the minimum speed needed for an object to break free from the gravitational influence of a celestial body without further propulsion.","title":"1.2 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-definition_1","text":"This velocity is derived from the conservation of energy principle: \\[ \\text{Kinetic Energy} + \\text{Potential Energy} = 0 \\] \\[ \\frac{1}{2}mv_2^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Alternatively: \\[ v_2 = \\sqrt{2}\\cdot v_1 \\]","title":"Mathematical Definition:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity-interstellar-escape-velocity","text":"The third cosmic velocity is the minimum speed required to escape the gravitational influence of an entire star system (e.g., the Solar System), starting from a planet\u2019s surface. This includes overcoming both: 1. The gravitational pull of the planet , 2. The gravitational pull of the star (e.g., the Sun).","title":"1.3 Third Cosmic Velocity (Interstellar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#approximate-mathematical-expression","text":"Let: - \\(v_{2,\\text{planet}}\\) : escape velocity from the planet - \\(v_{2,\\text{sun}}\\) : escape velocity from the Sun at the planet's orbital distance Then, the third cosmic velocity is approximately: \\[ v_3 = \\sqrt{v_{2,\\text{planet}}^2 + v_{2,\\text{sun}}^2} \\] A more detailed expression (from Earth's surface): \\[ v_3 = \\sqrt{2G\\left(\\frac{M_\\text{Earth}}{R_\\text{Earth}} + \\frac{M_\\text{Sun}}{d}\\right)} \\] Where: - \\(M_\\text{Earth}\\) and \\(R_\\text{Earth}\\) : Earth\u2019s mass and radius, - \\(M_\\text{Sun}\\) : Sun\u2019s mass, - \\(d\\) : distance from the Earth to the Sun.","title":"Approximate Mathematical Expression:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#14-physical-interpretation-and-differences","text":"Velocity Meaning Outcome Equation 1st Cosmic Velocity Minimum speed for stable circular orbit around a planet Orbit \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) 2nd Cosmic Velocity Minimum speed to escape a planet\u2019s gravity Leave the planet forever \\(v_2 = \\sqrt{\\frac{2GM}{r}}\\) 3rd Cosmic Velocity Minimum speed to escape the entire star system Leave the Solar System \\(v_3 = \\sqrt{v_{2,\\text{planet}}^2 + v_{2,\\text{sun}}^2}\\) Each of these velocities represents a critical threshold in mission design and trajectory planning in astrodynamics, from low-Earth orbits to interplanetary and interstellar travel.","title":"1.4 Physical Interpretation and Differences"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-analysis","text":"This section provides a rigorous derivation of the first, second, and third cosmic velocities using classical Newtonian mechanics. The parameters involved are identified and assumptions discussed.","title":"2. Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the speed at which an object must travel to maintain a stable circular orbit just above the surface of a celestial body, under the influence of gravity alone.","title":"2.1 First Cosmic Velocity \u2013 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation","text":"We equate the gravitational force to the centripetal force: \\[ F_\\text{gravity} = F_\\text{centripetal} \\] \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Canceling mass \\(m\\) and solving for \\(v\\) : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters","text":"\\(G\\) : Gravitational constant ( \\(6.674 \\times 10^{-11}~\\text{m}^3/\\text{kg}\\cdot\\text{s}^2\\) ) \\(M\\) : Mass of the planet or celestial body \\(r\\) : Distance from the center of the planet to the object (typically, the planet\u2019s radius for low orbits)","title":"Parameters:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#assumptions","text":"Circular orbit (eccentricity = 0) No air resistance Central mass is spherically symmetric and non-rotating","title":"Assumptions:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the minimum speed needed for an object to escape the gravitational field of a planet, assuming no propulsion after the initial launch.","title":"2.2 Second Cosmic Velocity \u2013 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation_1","text":"From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v\\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Or in terms of the first cosmic velocity: \\[ v_2 = \\sqrt{2} \\cdot v_1 \\]","title":"Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters_1","text":"Same as in first cosmic velocity","title":"Parameters:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#assumptions_1","text":"No energy loss (e.g., due to drag or friction) No further propulsion during flight Planet's mass is much larger than the object's mass","title":"Assumptions:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity-interstellar-escape-velocity","text":"The third cosmic velocity is the minimum speed required to escape the gravitational pull of both the Earth and the Sun \u2014 that is, to leave the Solar System entirely. This requires combining the escape velocity from Earth and the escape velocity from the Sun at Earth\u2019s orbital distance.","title":"2.3 Third Cosmic Velocity \u2013 Interstellar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation_2","text":"Let: - \\(v_{2,\\text{Earth}}\\) : escape velocity from Earth\u2019s surface - \\(v_{2,\\text{Sun}}\\) : escape velocity from the Sun at Earth\u2019s orbit Then, by energy conservation and vector addition (assuming aligned direction): \\[ v_3 = \\sqrt{v_{2,\\text{Earth}}^2 + v_{2,\\text{Sun}}^2} \\]","title":"Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity-from-the-sun-at-earths-orbit","text":"\\[ v_{2,\\text{Sun}} = \\sqrt{\\frac{2GM_\\text{Sun}}{d}} \\] Where: - \\(M_\\text{Sun}\\) : mass of the Sun - \\(d\\) : distance from the Sun to the Earth ( \\(\\approx 1.496 \\times 10^{11}~\\text{m}\\) ) Then the third cosmic velocity becomes: \\[ v_3 = \\sqrt{ \\left( \\sqrt{\\frac{2GM_\\text{Earth}}{R_\\text{Earth}}} \\right)^2 + \\left( \\sqrt{\\frac{2GM_\\text{Sun}}{d}} \\right)^2 } \\] Which simplifies to: \\[ v_3 = \\sqrt{ \\frac{2GM_\\text{Earth}}{R_\\text{Earth}} + \\frac{2GM_\\text{Sun}}{d} } \\]","title":"Escape velocity from the Sun at Earth's orbit:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters_2","text":"\\(M_\\text{Earth}\\) : mass of Earth \\(R_\\text{Earth}\\) : radius of Earth \\(M_\\text{Sun}\\) : mass of the Sun \\(d\\) : distance from Earth to Sun","title":"Parameters:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#assumptions_2","text":"No significant gravitational interactions from other planets Trajectory is radial and direct (idealized) No propulsion after launch Newtonian mechanics (relativistic effects neglected)","title":"Assumptions:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-table","text":"Velocity Formula Depends On First Cosmic ( \\(v_1\\) ) \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) \\(M\\) , \\(r\\) Second Cosmic ( \\(v_2\\) ) \\(v_2 = \\sqrt{\\frac{2GM}{r}}\\) \\(M\\) , \\(r\\) Third Cosmic ( \\(v_3\\) ) \\(v_3 = \\sqrt{\\frac{2GM_\\text{Earth}}{R_\\text{Earth}} + \\frac{2GM_\\text{Sun}}{d}}\\) \\(M_\\text{Earth}\\) , \\(R_\\text{Earth}\\) , \\(M_\\text{Sun}\\) , \\(d\\)","title":"Summary Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#planetary-velocity-calculations","text":"","title":"Planetary Velocity Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"In orbital mechanics, the velocity of a planet in orbit around the Sun is critical for understanding its motion. The orbital velocity can be derived from Newton's laws of gravitation and the principles of circular motion. The orbital velocity \\(v\\) of a planet can be calculated using the following formula: \\[ v = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(v\\) is the orbital velocity, - \\(G\\) is the gravitational constant \\((6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2})\\) , - \\(M\\) is the mass of the Sun \\((1.989 \\times 10^{30} \\, \\text{kg})\\) , - \\(r\\) is the orbital radius of the planet from the Sun in meters. The orbital velocity can be broken down into three main categories: - Circular Orbital Velocity (constant orbit), - Escape Velocity (velocity required to escape the Sun\u2019s gravity), - Orbital Period (time taken to complete one orbit). We will use actual planetary data for the following planets: 1. Earth 2. Mars 3. Jupiter","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-earth","text":"Orbital radius of Earth from the Sun: \\(r_{\\text{Earth}} = 1.496 \\times 10^{11} \\, \\text{m}\\) Orbital period of Earth: \\(T_{\\text{Earth}} = 365.25 \\, \\text{days}\\)","title":"1. Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earths-orbital-velocity","text":"Using the orbital velocity formula: \\[ v_{\\text{Earth}} = \\sqrt{\\frac{GM_{\\text{Sun}}}{r_{\\text{Earth}}}} \\] Substitute the known values: \\[ v_{\\text{Earth}} = \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (1.989 \\times 10^{30})}{1.496 \\times 10^{11}}} \\] The result will give the orbital velocity in meters per second.","title":"Earth's Orbital Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mars","text":"Orbital radius of Mars from the Sun: \\(r_{\\text{Mars}} = 2.279 \\times 10^{11} \\, \\text{m}\\) Orbital period of Mars: \\(T_{\\text{Mars}} = 687 \\, \\text{days}\\)","title":"2. Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars-orbital-velocity","text":"Similar to Earth, using the orbital velocity formula: \\[ v_{\\text{Mars}} = \\sqrt{\\frac{GM_{\\text{Sun}}}{r_{\\text{Mars}}}} \\] Substitute the known values: \\[ v_{\\text{Mars}} = \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (1.989 \\times 10^{30})}{2.279 \\times 10^{11}}} \\] The result will give the orbital velocity of Mars in meters per second.","title":"Mars' Orbital Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-jupiter","text":"Orbital radius of Jupiter from the Sun: \\(r_{\\text{Jupiter}} = 7.785 \\times 10^{11} \\, \\text{m}\\) Orbital period of Jupiter: \\(T_{\\text{Jupiter}} = 4333 \\, \\text{days}\\)","title":"3. Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiters-orbital-velocity","text":"Again, using the orbital velocity formula: \\[ v_{\\text{Jupiter}} = \\sqrt{\\frac{GM_{\\text{Sun}}}{r_{\\text{Jupiter}}}} \\] Substitute the known values: \\[ v_{\\text{Jupiter}} = \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (1.989 \\times 10^{30})}{7.785 \\times 10^{11}}} \\] The result will give the orbital velocity of Jupiter in meters per second.","title":"Jupiter's Orbital Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-implementation","text":"import math # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun in kg # Function to calculate orbital velocity def orbital_velocity(r): return math.sqrt(G * M_sun / r) # Planetary data (in meters) r_earth = 1.496e11 # Orbital radius of Earth r_mars = 2.279e11 # Orbital radius of Mars r_jupiter = 7.785e11 # Orbital radius of Jupiter # Calculate velocities v_earth = orbital_velocity(r_earth) v_mars = orbital_velocity(r_mars) v_jupiter = orbital_velocity(r_jupiter) # Output results print(f\"Orbital velocity of Earth: {v_earth:.2f} m/s\") print(f\"Orbital velocity of Mars: {v_mars:.2f} m/s\") print(f\"Orbital velocity of Jupiter: {v_jupiter:.2f} m/s\")","title":"Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#tabulated-results","text":"The table will look like this (values may vary slightly based on precision): Planet v\u2081 (Orbital) [km/s] v\u2082 (Escape) [km/s] v\u2083 (Solar Escape) [km/s] Earth ~7.91 ~11.18 ~42.1 Mars ~3.56 ~5.03 ~34.1 Jupiter ~42.1 ~59.5 ~87.3","title":"\ud83d\udcca Tabulated Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#notes","text":"These computations assume: Spherical symmetry No atmospheric drag Instantaneous velocity achieved (no thrust phase) \\(v_3\\) is approximate and assumes escape velocity from Sun calculated at the orbital distance of the planet.","title":"\ud83d\udccc Notes"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-visualizationsplots","text":"In this section, we create visualizations to compare the cosmic velocities for Earth, Mars, and Jupiter. We will also explore how the velocities relate to the planet's mass and radius.","title":"4. Visualizations/Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#bar-chart-cosmic-velocities-for-earth-mars-and-jupiter","text":"We will plot the first , second , and third cosmic velocities for each planet using bar charts for easy comparison.","title":"\ud83d\udcca Bar Chart: Cosmic Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"import matplotlib.pyplot as plt # Extracting data for plotting planets_names = ['Earth', 'Mars', 'Jupiter'] v1_values = [row['v1 (Orbital) [km/s]'] for _, row in df.iterrows()] v2_values = [row['v2 (Escape) [km/s]'] for _, row in df.iterrows()] v3_values = [row['v3 (Solar Escape) [km/s]'] for _, row in df.iterrows()] # Bar chart fig, ax = plt.subplots(figsize=(10, 6)) width = 0.25 # Bar width x = np.arange(len(planets_names)) # Create bars for each velocity type ax.bar(x - width, v1_values, width, label='First Cosmic Velocity') ax.bar(x, v2_values, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_values, width, label='Third Cosmic Velocity') # Formatting ax.set_xlabel('Planets') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(planets_names) ax.legend() plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#velocity-vs-planet-mass-and-radius","text":"We will create two plots to investigate how the cosmic velocities vary with the planet's mass and radius .","title":"\ud83c\udf0d Velocity vs. Planet Mass and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-velocity-vs-planet-mass","text":"We will create two plots to investigate how the cosmic velocities vary with the","title":"1. Velocity vs. Planet Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-velocity-vs-planet-radius","text":"","title":"2. Velocity vs. Planet Radius"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#optional-3d-or-animation-based-visuals-for-conceptual-understanding","text":"For deeper understanding, we can visualize the velocities in 3D space or through animations .","title":"\ud83c\udf10 Optional: 3D or Animation-Based Visuals for Conceptual Understanding"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-3d-plot-of-cosmic-velocities","text":"","title":"1. 3D Plot of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_4","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-animation-of-planetary-escape","text":"","title":"2. Animation of Planetary Escape"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_5","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#_6","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#final-thoughts","text":"","title":"\ud83d\udcc8 Final Thoughts"},{"location":"1%20Physics/2%20Gravity/Problem_2/#-the-bar-charts-and-line-plots-offer-a-comparative-view-of-cosmic-velocities-across-different-planets","text":"","title":"- The bar charts and line plots offer a comparative view of cosmic velocities across different planets."},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-application-discussion","text":"","title":"5. Application &amp; Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-importance-of-each-cosmic-velocity-in-real-world-space-missions","text":"The concept of cosmic velocities plays a crucial role in modern space exploration. Understanding these velocities is essential for designing spacecraft and planning interplanetary or interstellar missions. Here we explore the significance of each cosmic velocity:","title":"\ud83d\ude80 1. Importance of Each Cosmic Velocity in Real-World Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity-orbital-velocity_1","text":"The first cosmic velocity is the minimum speed required for an object to remain in a stable orbit around a planet or star. Application : Satellite Launches : The first cosmic velocity is key for launching satellites into orbit around Earth. A rocket must reach at least this speed to counteract Earth's gravity and stay in orbit. Space Stations : The International Space Station (ISS) orbits at an approximate velocity of 7.66 km/s, which is just slightly above Earth's first cosmic velocity. Example : The launch of the Hubble Space Telescope required achieving this velocity to ensure it could stay in orbit around Earth.","title":"1.1 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity-escape-velocity_1","text":"The second cosmic velocity is the minimum velocity required to escape a celestial body's gravitational influence. This is the speed needed for a spacecraft to break free from Earth\u2019s gravity without further propulsion. Application : Escape from Earth's Gravity : Spacecraft like the Apollo missions or the Mars rovers use this velocity to leave Earth\u2019s atmosphere and escape into interplanetary space. Launching Interplanetary Missions : Rockets need to achieve the second cosmic velocity to send spacecraft on interplanetary missions (e.g., to Mars or Jupiter). Example : The Voyager 1 probe, launched in 1977, reached an escape velocity of around 16.5 km/s, allowing it to break free from Earth\u2019s gravitational influence and begin its journey to interstellar space.","title":"1.2 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity-solar-system-escape-velocity","text":"The third cosmic velocity is the velocity needed to escape not just a planet, but the entire solar system , including escaping the Sun\u2019s gravity. Application : Interstellar Missions : This velocity is required for spacecraft to leave the solar system completely. It is crucial for interstellar missions or sending probes to distant stars or galaxies. Escape from Solar System : Missions aiming to travel beyond the influence of the Sun\u2019s gravity need to achieve this velocity. Example : The Voyager 1 spacecraft achieved this velocity after escaping Earth\u2019s gravity, enabling it to travel toward the interstellar medium . Currently, it is the farthest human-made object from Earth.","title":"1.3 Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-relating-cosmic-velocities-to-historical-and-planned-space-missions","text":"","title":"\ud83c\udf0c 2. Relating Cosmic Velocities to Historical and Planned Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-voyager-missions-voyager-1-2","text":"Voyager 1 , launched in 1977, and Voyager 2 , launched in 1977 as well, are key examples of space probes that have used the second and third cosmic velocities to escape Earth\u2019s gravity and the Sun's gravitational pull. Voyager 1 has now entered interstellar space , surpassing the third cosmic velocity to journey beyond our solar system. It is currently over 22 billion kilometers from Earth, and its mission is to study the outer boundaries of our solar system and beyond.","title":"2.1 Voyager Missions (Voyager 1 &amp; 2)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-artemis-program","text":"NASA\u2019s Artemis program , planned for the coming years, aims to send humans back to the Moon and eventually to Mars. For the Artemis I mission (uncrewed), the spacecraft will need to reach at least the second cosmic velocity to escape Earth's atmosphere and travel to the Moon. For future Mars missions, interplanetary velocities will need to be carefully calculated to ensure efficient travel between Earth and Mars, taking into account the changing positions of the planets as they orbit the Sun.","title":"2.2 Artemis Program"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-mars-rover-missions","text":"NASA's Mars rovers , such as Curiosity and Perseverance , need to overcome Earth's gravity (second cosmic velocity) to reach Mars, and then use orbital velocities to safely enter Mars\u2019 atmosphere for landing. Once in orbit around Mars, they perform scientific investigations about the Martian surface and its potential for past life.","title":"2.3 Mars Rover Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-conclusion","text":"The understanding and application of the first , second , and third cosmic velocities are fundamental for planning space missions, from launching satellites into Earth orbit to sending probes into interstellar space. These velocities help scientists and engineers design spacecraft that can successfully complete their missions and overcome the gravitational challenges posed by celestial bodies. Space exploration will continue to rely on these principles to push the boundaries of our solar system and beyond, and understanding them is key to missions like Voyager , Artemis , and future interstellar travel.","title":"\ud83c\udf20 3. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Motivation Interference occurs when multiple wave sources overlap in space and time, forming a new resultant wave pattern. On a water surface, this is observable as ripple patterns that vary in intensity depending on the positions and phases of the sources. This forms the basis of constructive interference (wave amplification) and destructive interference (wave cancellation). Studying wave interference helps us understand key physics concepts like superposition , phase relationships , and wave propagation \u2014 relevant in fields ranging from acoustics and optics to quantum physics and antenna design. 2. Mathematical Foundations 2.1 Circular Wave from a Point Source A point source located at \\((x_0,y_0)\\) emits a circular wave that propagates outward. The displacement \\(\\eta(x,y,t)\\) of the water surface at a point \\((x,y)\\) and time \\(t\\) is given by: $$ \\eta(x,y,t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) $$ Where: \\(A\\) : amplitude of the wave \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from the source to the point \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number \\(\\lambda\\) : wavelength \\(\\omega = 2\\pi f\\) : angular frequency \\(f\\) : frequency \\(\\phi\\) : initial phase of the wave import numpy as np import matplotlib.pyplot as plt # Izgara olu\u015ftur x = np.linspace(-50, 50, 500) y = np.linspace(-50, 50, 500) X, Y = np.meshgrid(x, y) # Noktasal kaynaktan uzakl\u0131k (r) r = np.sqrt(X**2 + Y**2) # Dalga fonksiyonu wave = np.sin(r) # Grafik \u00e7izimi plt.figure(figsize=(6, 6)) plt.imshow(wave, extent=[-50, 50, -50, 50], origin='lower', cmap='viridis') plt.colorbar(label='Amplitude') plt.title('Single Circular Wave from a Point Source') plt.xlabel('x') plt.ylabel('y') plt.show() ``` ### 2.2 Superposition of Multiple Waves When there are $N$ point sources, each emitting coherent waves, the total displacement at a point $(x,y)$ is the **sum** of the displacements from each source: $$ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(kr_i - \\omega t + \\phi_i) $$ Where each $r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}$ is the distance from the $i$-th source located at $(x_i, y_i)$, and $\\phi_i$ is the initial phase of that source. ### 2.3 Source Geometry: Regular Polygon Configuration To ensure symmetry and regular interference patterns, sources are placed at the vertices of a regular polygon with radius $R$ centered at the origin. The coordinates of the $i$-th source (for $N$ total sources) are: $$ (x_i, y_i) = \\left(R \\cos\\left(\\frac{2\\pi i}{N}\\right), R \\sin\\left(\\frac{2\\pi i}{N}\\right)\\right), \\quad i = 0, 1, \\dots, N-1 $$ This configuration leads to symmetric and often beautiful interference patterns, especially when $N = 3$ (triangle), $N = 4$ (square), $N = 5$ (pentagon), etc. ## 3. Interference Analysis ### 3.1 Constructive Interference Occurs when wave crests meet crests and troughs meet troughs, leading to amplification: $$ \\Delta\\phi = 2\\pi n, \\quad n \\in \\mathbb{Z} $$ ### 3.2 Destructive Interference ### 3.1 Constructive Interference Occurs when wave crests meet crests and troughs meet troughs, leading to amplification: $$ \\Delta\\phi = 2\\pi n, \\quad n \\in \\mathbb{Z} $$ ### 3.2 Destructive Interference Occurs when wave crests meet troughs, leading to cancellation: $$ \\Delta\\phi = (2n + 1)\\pi, \\quad n \\in \\mathbb{Z} $$ These conditions are crucial in analyzing the positions of **nodal lines** (destructive zones) and **antinodal lines** (constructive zones). --- # Moir\u00e9 Wave Interference Visualization with interactive sliders ![alt text](image-1.png) ```python import numpy as np import matplotlib.pyplot as plt from ipywidgets import interact, FloatSlider # Grid x = np.linspace(-10, 10, 600) y = np.linspace(-10, 10, 600) X, Y = np.meshgrid(x, y) def moire_wave(theta1=0, theta2=30, k1=1.0, k2=1.05, phase=0.0): # Dalga y\u00f6nlerini radyana \u00e7evir t1 = np.radians(theta1) t2 = np.radians(theta2) # \u0130ki d\u00fczlem dalgas\u0131 tan\u0131mla wave1 = np.cos(k1 * (X * np.cos(t1) + Y * np.sin(t1))) wave2 = np.cos(k2 * (X * np.cos(t2) + Y * np.sin(t2)) + phase) # \u00dcst \u00fcste bindirme (interference) result = wave1 + wave2 # G\u00f6rselle\u015ftir plt.figure(figsize=(8, 8)) plt.imshow(result, extent=[-10, 10, -10, 10], cmap='inferno', origin='lower') plt.title('Moir\u00e9 Interference Pattern') plt.axis('off') plt.tight_layout() plt.show() # Etkile\u015fimli aray\u00fcz interact( moire_wave, theta1=FloatSlider(min=0, max=180, step=1, value=0, description='Angle 1 (\u00b0)'), theta2=FloatSlider(min=0, max=180, step=1, value=30, description='Angle 2 (\u00b0)'), k1=FloatSlider(min=0.5, max=2.0, step=0.01, value=1.0, description='k1'), k2=FloatSlider(min=0.5, max=2.0, step=0.01, value=1.05, description='k2'), phase=FloatSlider(min=0.0, max=2*np.pi, step=0.1, value=0.0, description='Phase \u0394\u03c6'), ) Moir\u00e9 Wave Interference Visualization This Python code creates an interactive 2D visualization of moir\u00e9 interference patterns formed by the superposition of two plane waves. What it does: \u2022 Simulates two waves traveling at different angles and wave numbers (k1, k2). \u2022 The result of their interference is displayed as a moir\u00e9 pattern \u2014 a visually striking pattern that looks 3D or holographic. \u2022 Uses sliders (ipywidgets) to control: \u2022 Angles of each wave \u2022 Wave numbers (spatial frequency) \u2022 Phase offset \u2e3b Purpose: To explore how small differences in wave direction and frequency create complex interference patterns \u2014 useful in optics, physics, and signal processing. 4. Parameters and Their Effects Parameter Symbol Effect on Pattern Amplitude \\(A\\) Affects brightness/intensity of plot, not pattern shape Wavelength \\(\\lambda\\) Larger \\(\\lambda\\) \u2192 wider fringes Frequency \\(f\\) Affects speed of time-dependent animation, not pattern shape Phase Offset \\(\\phi\\) Can shift/interfere patterns asymmetrically Number of Sources \\(N\\) More sources = richer, more complex patterns Polygon Radius \\(R\\) Affects spacing and detail in the pattern --- # interference patterns on a water surface \ud83c\udfaf objective Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. steps to follow 1. select a regular polygon We choose a regular polygon \u2014 for example: - equilateral triangle - square - regular pentagon Let the polygon have \\(N\\) vertices (and hence \\(N\\) point sources), placed symmetrically around a circle of radius \\(R\\) centered at the origin. Each vertex (source position) is given by: $$ \\vec{r}_i = \\left(R \\cos\\left(\\theta_i\\right), R \\sin\\left(\\theta_i\\right)\\right), \\quad \\theta_i = \\frac{2\\pi(i-1)}{N}, \\quad i = 1, 2, \\dots, N $$ 2. position the sources We place point wave sources at these \\(N\\) vertices. All sources emit coherent circular waves with: same amplitude \\(A\\) same wavelength \\(\\lambda\\) same frequency \\(f\\) same initial phase \\(\\phi = 0\\) 3. wave equations The wave emitted from the \\(i\\) -th source located at \\(\\vec{r}_i\\) is described by: \\[ \\eta_i(x, y, t) = A \\cdot \\cos\\left(k \\cdot |\\vec{r} - \\vec{r}_i| - \\omega t \\right) \\] Where: - \\(\\vec{r} = (x, y)\\) is the observation point on the water surface - \\(k = \\dfrac{2\\pi}{\\lambda}\\) is the wave number - \\(\\omega = 2\\pi f\\) is the angular frequency - \\(|\\vec{r} - \\vec{r}_i|\\) is the Euclidean distance between the observation point and source \\(i\\) 4. superposition of waves By the principle of superposition, the total displacement at point \\((x, y)\\) and time \\(t\\) is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos\\left(k \\cdot |\\vec{r} - \\vec{r}_i| - \\omega t \\right) \\] This total wave function governs the interference pattern on the water surface. Analyze interference patterns We analyze \\(\\eta_{\\text{sum}}(x, y, t)\\) to find: constructive interference : When waves arrive in phase , amplifying displacement. destructive interference : When waves arrive out of phase , leading to cancellation. These patterns depend on the differences in distance from each point to the sources, and hence on the geometry of the polygon. import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength (lambda) k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0 # Phase # Grid setup x_range = y_range = 5.0 resolution = 500 x = np.linspace(-x_range, x_range, resolution) y = np.linspace(-y_range, y_range, resolution) X, Y = np.meshgrid(x, y) # Time snapshot (can loop later for animation) t = 0 # Polygon setup N = 5 # Number of sources (e.g., 3 for triangle, 4 for square, 5 for pentagon) R = 2.0 # Radius of polygon # Source positions angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] # Compute total wave field eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_i = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) eta_sum += eta_i # Plotting plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, eta_sum, shading='auto', cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.title(f'Interference Pattern from {N} Coherent Sources (Polygon)') plt.xlabel('x') plt.ylabel('y') plt.gca().set_aspect('equal') plt.grid(False) plt.tight_layout() plt.show() Wave Interference Simulation This code visualizes the interference pattern created by multiple circular wave sources arranged in a regular polygon. \u2e3b \ud83d\udd27 What It Does \u2022 Places N wave sources on a circle (polygon). \u2022 Each source emits a circular wave. \u2022 Uses the superposition principle to compute total wave displacement on a 2D grid. \u2022 Plots the result as a color map showing constructive and destructive interference. \u2e3b \ud83e\uddea Key Parameters \u2022 A: Amplitude \u2022 \u03bb: Wavelength \u2022 f: Frequency \u2022 N: Number of sources (e.g. 3 = triangle, 5 = pentagon) \u2022 R: Radius of the polygon \u2022 t: Time snapshot (static) \u2e3b \ud83d\udcca Output \u2022 A 2D plot of the wave interference pattern \u2022 Shows how waves from multiple sources interact over space. Interactive Wave Interference Simulation with Animation (with sliders) import numpy as np import matplotlib.pyplot as plt from matplotlib import animation from IPython.display import display, HTML, clear_output import ipywidgets as widgets import matplotlib as mpl # G\u00f6m\u00fclecek maksimum animasyon boyutunu y\u00fckselt mpl.rcParams['animation.embed_limit'] = 50_000_000 # Sabit grid x = np.linspace(-10, 10, 200) y = np.linspace(-10, 10, 200) X, Y = np.meshgrid(x, y) # Parametreleri tut params = { 'A': 1.0, 'wavelength': 2.0, 'f': 1.0, 'phase_diff': 0.0, 'R': 3.0, 'N': 3 } def compute_frame(t): A = params['A'] wavelength = params['wavelength'] f = params['f'] phase_diff = params['phase_diff'] R = params['R'] N = int(params['N']) k = 2 * np.pi / wavelength omega = 2 * np.pi * f eta_sum = np.zeros_like(X) for i in range(N): angle = 2 * np.pi * i / N sx = R * np.cos(angle) sy = R * np.sin(angle) r = np.sqrt((X - sx)**2 + (Y - sy)**2) phi = i * phase_diff eta = A / np.sqrt(r + 0.1) * np.cos(k * r - omega * t + phi) eta_sum += eta return eta_sum # Animasyon olu\u015fturma fonksiyonu def create_animation(): fig, ax = plt.subplots(figsize=(6, 6)) img = ax.imshow(np.zeros_like(X), extent=[-10, 10, -10, 10], cmap='viridis', origin='lower') cb = plt.colorbar(img, ax=ax) ax.set_title('Interference Pattern') def update(frame): eta = compute_frame(frame / 10.0) img.set_data(eta) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) plt.close() return HTML(ani.to_jshtml()) # Widgetlar A_slider = widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Amplitude') wavelength_slider = widgets.FloatSlider(value=2.0, min=0.5, max=10.0, step=0.1, description='Wavelength') f_slider = widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Frequency') phase_slider = widgets.FloatSlider(value=0.0, min=0.0, max=2*np.pi, step=0.1, description='Phase \u0394\u03c6') R_slider = widgets.FloatSlider(value=3.0, min=1.0, max=10.0, step=0.5, description='Radius R') N_slider = widgets.IntSlider(value=3, min=2, max=10, step=1, description='Sources N') sliders = [A_slider, wavelength_slider, f_slider, phase_slider, R_slider, N_slider] # Her de\u011fi\u015fiklikte animasyonu yenile output = widgets.Output() def on_slider_change(change): # G\u00fcncel de\u011ferleri al params['A'] = A_slider.value params['wavelength'] = wavelength_slider.value params['f'] = f_slider.value params['phase_diff'] = phase_slider.value params['R'] = R_slider.value params['N'] = N_slider.value with output: clear_output(wait=True) display(create_animation()) for s in sliders: s.observe(on_slider_change, names='value') # \u0130lk g\u00f6sterim on_slider_change(None) # T\u00fcm aray\u00fcz controls = widgets.VBox(sliders) display(widgets.HBox([controls, output])) https://colab.research.google.com/drive/1hfJSBa6viabQ6Nu6VgxikyWLtrBGrjvc#scrollTo=nrSTgKbf0PBA&line=2&uniqifier=1: Description: This Python code creates an interactive and animated simulation of wave interference, designed to run inside a Jupyter Notebook or Google Colab environment. \ud83d\udd27 What It Does: \u2022 Simulates circular waves emitted from multiple sources arranged in a regular polygon (triangle, square, pentagon, etc.). \u2022 Calculates the resulting interference pattern by summing all wave contributions over a 2D grid using the superposition principle. \u2022 Uses matplotlib.animation to generate a looping animation of the wave field over time. \u2022 Displays an interactive control panel (sliders) using ipywidgets to let users change key parameters in real-time: \u2022 Amplitude (A) \u2022 Wavelength (\u03bb) \u2022 Frequency (f) \u2022 Phase Difference (\u0394\u03c6) \u2022 Polygon Radius (R) \u2022 Number of Sources (N) \ud83d\uddbc Output: \u2022 Left: Interactive sliders for adjusting parameters. \u2022 Right: Real-time animated heatmap showing the interference pattern evolving over time. \u2022 The color pattern represents wave peaks and troughs, showing constructive and destructive interference zones.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-motivation","text":"Interference occurs when multiple wave sources overlap in space and time, forming a new resultant wave pattern. On a water surface, this is observable as ripple patterns that vary in intensity depending on the positions and phases of the sources. This forms the basis of constructive interference (wave amplification) and destructive interference (wave cancellation). Studying wave interference helps us understand key physics concepts like superposition , phase relationships , and wave propagation \u2014 relevant in fields ranging from acoustics and optics to quantum physics and antenna design.","title":"1. Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-mathematical-foundations","text":"","title":"2. Mathematical Foundations"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-circular-wave-from-a-point-source","text":"A point source located at \\((x_0,y_0)\\) emits a circular wave that propagates outward. The displacement \\(\\eta(x,y,t)\\) of the water surface at a point \\((x,y)\\) and time \\(t\\) is given by: $$ \\eta(x,y,t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) $$ Where: \\(A\\) : amplitude of the wave \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from the source to the point \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number \\(\\lambda\\) : wavelength \\(\\omega = 2\\pi f\\) : angular frequency \\(f\\) : frequency \\(\\phi\\) : initial phase of the wave import numpy as np import matplotlib.pyplot as plt # Izgara olu\u015ftur x = np.linspace(-50, 50, 500) y = np.linspace(-50, 50, 500) X, Y = np.meshgrid(x, y) # Noktasal kaynaktan uzakl\u0131k (r) r = np.sqrt(X**2 + Y**2) # Dalga fonksiyonu wave = np.sin(r) # Grafik \u00e7izimi plt.figure(figsize=(6, 6)) plt.imshow(wave, extent=[-50, 50, -50, 50], origin='lower', cmap='viridis') plt.colorbar(label='Amplitude') plt.title('Single Circular Wave from a Point Source') plt.xlabel('x') plt.ylabel('y') plt.show() ``` ### 2.2 Superposition of Multiple Waves When there are $N$ point sources, each emitting coherent waves, the total displacement at a point $(x,y)$ is the **sum** of the displacements from each source: $$ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(kr_i - \\omega t + \\phi_i) $$ Where each $r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}$ is the distance from the $i$-th source located at $(x_i, y_i)$, and $\\phi_i$ is the initial phase of that source. ### 2.3 Source Geometry: Regular Polygon Configuration To ensure symmetry and regular interference patterns, sources are placed at the vertices of a regular polygon with radius $R$ centered at the origin. The coordinates of the $i$-th source (for $N$ total sources) are: $$ (x_i, y_i) = \\left(R \\cos\\left(\\frac{2\\pi i}{N}\\right), R \\sin\\left(\\frac{2\\pi i}{N}\\right)\\right), \\quad i = 0, 1, \\dots, N-1 $$ This configuration leads to symmetric and often beautiful interference patterns, especially when $N = 3$ (triangle), $N = 4$ (square), $N = 5$ (pentagon), etc. ## 3. Interference Analysis ### 3.1 Constructive Interference Occurs when wave crests meet crests and troughs meet troughs, leading to amplification: $$ \\Delta\\phi = 2\\pi n, \\quad n \\in \\mathbb{Z} $$ ### 3.2 Destructive Interference ### 3.1 Constructive Interference Occurs when wave crests meet crests and troughs meet troughs, leading to amplification: $$ \\Delta\\phi = 2\\pi n, \\quad n \\in \\mathbb{Z} $$ ### 3.2 Destructive Interference Occurs when wave crests meet troughs, leading to cancellation: $$ \\Delta\\phi = (2n + 1)\\pi, \\quad n \\in \\mathbb{Z} $$ These conditions are crucial in analyzing the positions of **nodal lines** (destructive zones) and **antinodal lines** (constructive zones). --- # Moir\u00e9 Wave Interference Visualization with interactive sliders ![alt text](image-1.png) ```python import numpy as np import matplotlib.pyplot as plt from ipywidgets import interact, FloatSlider # Grid x = np.linspace(-10, 10, 600) y = np.linspace(-10, 10, 600) X, Y = np.meshgrid(x, y) def moire_wave(theta1=0, theta2=30, k1=1.0, k2=1.05, phase=0.0): # Dalga y\u00f6nlerini radyana \u00e7evir t1 = np.radians(theta1) t2 = np.radians(theta2) # \u0130ki d\u00fczlem dalgas\u0131 tan\u0131mla wave1 = np.cos(k1 * (X * np.cos(t1) + Y * np.sin(t1))) wave2 = np.cos(k2 * (X * np.cos(t2) + Y * np.sin(t2)) + phase) # \u00dcst \u00fcste bindirme (interference) result = wave1 + wave2 # G\u00f6rselle\u015ftir plt.figure(figsize=(8, 8)) plt.imshow(result, extent=[-10, 10, -10, 10], cmap='inferno', origin='lower') plt.title('Moir\u00e9 Interference Pattern') plt.axis('off') plt.tight_layout() plt.show() # Etkile\u015fimli aray\u00fcz interact( moire_wave, theta1=FloatSlider(min=0, max=180, step=1, value=0, description='Angle 1 (\u00b0)'), theta2=FloatSlider(min=0, max=180, step=1, value=30, description='Angle 2 (\u00b0)'), k1=FloatSlider(min=0.5, max=2.0, step=0.01, value=1.0, description='k1'), k2=FloatSlider(min=0.5, max=2.0, step=0.01, value=1.05, description='k2'), phase=FloatSlider(min=0.0, max=2*np.pi, step=0.1, value=0.0, description='Phase \u0394\u03c6'), )","title":"2.1 Circular Wave from a Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#moire-wave-interference-visualization","text":"This Python code creates an interactive 2D visualization of moir\u00e9 interference patterns formed by the superposition of two plane waves.","title":"Moir\u00e9 Wave Interference Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#what-it-does","text":"\u2022 Simulates two waves traveling at different angles and wave numbers (k1, k2). \u2022 The result of their interference is displayed as a moir\u00e9 pattern \u2014 a visually striking pattern that looks 3D or holographic. \u2022 Uses sliders (ipywidgets) to control: \u2022 Angles of each wave \u2022 Wave numbers (spatial frequency) \u2022 Phase offset \u2e3b","title":"What it does:"},{"location":"1%20Physics/3%20Waves/Problem_1/#purpose","text":"To explore how small differences in wave direction and frequency create complex interference patterns \u2014 useful in optics, physics, and signal processing.","title":"Purpose:"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-parameters-and-their-effects","text":"Parameter Symbol Effect on Pattern Amplitude \\(A\\) Affects brightness/intensity of plot, not pattern shape Wavelength \\(\\lambda\\) Larger \\(\\lambda\\) \u2192 wider fringes Frequency \\(f\\) Affects speed of time-dependent animation, not pattern shape Phase Offset \\(\\phi\\) Can shift/interfere patterns asymmetrically Number of Sources \\(N\\) More sources = richer, more complex patterns Polygon Radius \\(R\\) Affects spacing and detail in the pattern --- # interference patterns on a water surface","title":"4. Parameters and Their Effects"},{"location":"1%20Physics/3%20Waves/Problem_1/#objective","text":"Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon.","title":"\ud83c\udfaf objective"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"","title":"steps to follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-select-a-regular-polygon","text":"We choose a regular polygon \u2014 for example: - equilateral triangle - square - regular pentagon Let the polygon have \\(N\\) vertices (and hence \\(N\\) point sources), placed symmetrically around a circle of radius \\(R\\) centered at the origin. Each vertex (source position) is given by: $$ \\vec{r}_i = \\left(R \\cos\\left(\\theta_i\\right), R \\sin\\left(\\theta_i\\right)\\right), \\quad \\theta_i = \\frac{2\\pi(i-1)}{N}, \\quad i = 1, 2, \\dots, N $$","title":"1. select a regular polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-position-the-sources","text":"We place point wave sources at these \\(N\\) vertices. All sources emit coherent circular waves with: same amplitude \\(A\\) same wavelength \\(\\lambda\\) same frequency \\(f\\) same initial phase \\(\\phi = 0\\)","title":"2. position the sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-wave-equations","text":"The wave emitted from the \\(i\\) -th source located at \\(\\vec{r}_i\\) is described by: \\[ \\eta_i(x, y, t) = A \\cdot \\cos\\left(k \\cdot |\\vec{r} - \\vec{r}_i| - \\omega t \\right) \\] Where: - \\(\\vec{r} = (x, y)\\) is the observation point on the water surface - \\(k = \\dfrac{2\\pi}{\\lambda}\\) is the wave number - \\(\\omega = 2\\pi f\\) is the angular frequency - \\(|\\vec{r} - \\vec{r}_i|\\) is the Euclidean distance between the observation point and source \\(i\\)","title":"3. wave equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-of-waves","text":"By the principle of superposition, the total displacement at point \\((x, y)\\) and time \\(t\\) is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos\\left(k \\cdot |\\vec{r} - \\vec{r}_i| - \\omega t \\right) \\] This total wave function governs the interference pattern on the water surface.","title":"4. superposition of waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#analyze-interference-patterns","text":"We analyze \\(\\eta_{\\text{sum}}(x, y, t)\\) to find: constructive interference : When waves arrive in phase , amplifying displacement. destructive interference : When waves arrive out of phase , leading to cancellation. These patterns depend on the differences in distance from each point to the sources, and hence on the geometry of the polygon. import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength (lambda) k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0 # Phase # Grid setup x_range = y_range = 5.0 resolution = 500 x = np.linspace(-x_range, x_range, resolution) y = np.linspace(-y_range, y_range, resolution) X, Y = np.meshgrid(x, y) # Time snapshot (can loop later for animation) t = 0 # Polygon setup N = 5 # Number of sources (e.g., 3 for triangle, 4 for square, 5 for pentagon) R = 2.0 # Radius of polygon # Source positions angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] # Compute total wave field eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_i = A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) eta_sum += eta_i # Plotting plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, eta_sum, shading='auto', cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.title(f'Interference Pattern from {N} Coherent Sources (Polygon)') plt.xlabel('x') plt.ylabel('y') plt.gca().set_aspect('equal') plt.grid(False) plt.tight_layout() plt.show()","title":"Analyze interference patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-simulation","text":"This code visualizes the interference pattern created by multiple circular wave sources arranged in a regular polygon. \u2e3b","title":"Wave Interference Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#what-it-does_1","text":"\u2022 Places N wave sources on a circle (polygon). \u2022 Each source emits a circular wave. \u2022 Uses the superposition principle to compute total wave displacement on a 2D grid. \u2022 Plots the result as a color map showing constructive and destructive interference. \u2e3b","title":"\ud83d\udd27 What It Does"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-parameters","text":"\u2022 A: Amplitude \u2022 \u03bb: Wavelength \u2022 f: Frequency \u2022 N: Number of sources (e.g. 3 = triangle, 5 = pentagon) \u2022 R: Radius of the polygon \u2022 t: Time snapshot (static) \u2e3b","title":"\ud83e\uddea Key Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#output","text":"\u2022 A 2D plot of the wave interference pattern \u2022 Shows how waves from multiple sources interact over space.","title":"\ud83d\udcca Output"},{"location":"1%20Physics/3%20Waves/Problem_1/#interactive-wave-interference-simulation-with-animation-with-sliders","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib import animation from IPython.display import display, HTML, clear_output import ipywidgets as widgets import matplotlib as mpl # G\u00f6m\u00fclecek maksimum animasyon boyutunu y\u00fckselt mpl.rcParams['animation.embed_limit'] = 50_000_000 # Sabit grid x = np.linspace(-10, 10, 200) y = np.linspace(-10, 10, 200) X, Y = np.meshgrid(x, y) # Parametreleri tut params = { 'A': 1.0, 'wavelength': 2.0, 'f': 1.0, 'phase_diff': 0.0, 'R': 3.0, 'N': 3 } def compute_frame(t): A = params['A'] wavelength = params['wavelength'] f = params['f'] phase_diff = params['phase_diff'] R = params['R'] N = int(params['N']) k = 2 * np.pi / wavelength omega = 2 * np.pi * f eta_sum = np.zeros_like(X) for i in range(N): angle = 2 * np.pi * i / N sx = R * np.cos(angle) sy = R * np.sin(angle) r = np.sqrt((X - sx)**2 + (Y - sy)**2) phi = i * phase_diff eta = A / np.sqrt(r + 0.1) * np.cos(k * r - omega * t + phi) eta_sum += eta return eta_sum # Animasyon olu\u015fturma fonksiyonu def create_animation(): fig, ax = plt.subplots(figsize=(6, 6)) img = ax.imshow(np.zeros_like(X), extent=[-10, 10, -10, 10], cmap='viridis', origin='lower') cb = plt.colorbar(img, ax=ax) ax.set_title('Interference Pattern') def update(frame): eta = compute_frame(frame / 10.0) img.set_data(eta) return [img] ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True) plt.close() return HTML(ani.to_jshtml()) # Widgetlar A_slider = widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Amplitude') wavelength_slider = widgets.FloatSlider(value=2.0, min=0.5, max=10.0, step=0.1, description='Wavelength') f_slider = widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Frequency') phase_slider = widgets.FloatSlider(value=0.0, min=0.0, max=2*np.pi, step=0.1, description='Phase \u0394\u03c6') R_slider = widgets.FloatSlider(value=3.0, min=1.0, max=10.0, step=0.5, description='Radius R') N_slider = widgets.IntSlider(value=3, min=2, max=10, step=1, description='Sources N') sliders = [A_slider, wavelength_slider, f_slider, phase_slider, R_slider, N_slider] # Her de\u011fi\u015fiklikte animasyonu yenile output = widgets.Output() def on_slider_change(change): # G\u00fcncel de\u011ferleri al params['A'] = A_slider.value params['wavelength'] = wavelength_slider.value params['f'] = f_slider.value params['phase_diff'] = phase_slider.value params['R'] = R_slider.value params['N'] = N_slider.value with output: clear_output(wait=True) display(create_animation()) for s in sliders: s.observe(on_slider_change, names='value') # \u0130lk g\u00f6sterim on_slider_change(None) # T\u00fcm aray\u00fcz controls = widgets.VBox(sliders) display(widgets.HBox([controls, output])) https://colab.research.google.com/drive/1hfJSBa6viabQ6Nu6VgxikyWLtrBGrjvc#scrollTo=nrSTgKbf0PBA&line=2&uniqifier=1:","title":"Interactive Wave Interference Simulation with Animation (with sliders)"},{"location":"1%20Physics/3%20Waves/Problem_1/#description","text":"This Python code creates an interactive and animated simulation of wave interference, designed to run inside a Jupyter Notebook or Google Colab environment.","title":"Description:"},{"location":"1%20Physics/3%20Waves/Problem_1/#what-it-does_2","text":"\u2022 Simulates circular waves emitted from multiple sources arranged in a regular polygon (triangle, square, pentagon, etc.). \u2022 Calculates the resulting interference pattern by summing all wave contributions over a 2D grid using the superposition principle. \u2022 Uses matplotlib.animation to generate a looping animation of the wave field over time. \u2022 Displays an interactive control panel (sliders) using ipywidgets to let users change key parameters in real-time: \u2022 Amplitude (A) \u2022 Wavelength (\u03bb) \u2022 Frequency (f) \u2022 Phase Difference (\u0394\u03c6) \u2022 Polygon Radius (R) \u2022 Number of Sources (N)","title":"\ud83d\udd27 What It Does:"},{"location":"1%20Physics/3%20Waves/Problem_1/#output_1","text":"\u2022 Left: Interactive sliders for adjusting parameters. \u2022 Right: Real-time animated heatmap showing the interference pattern evolving over time. \u2022 The color pattern represents wave peaks and troughs, showing constructive and destructive interference zones.","title":"\ud83d\uddbc Output:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force 1. Introduction and Motivation The Lorentz force governs the motion of charged particles in electromagnetic fields and is essential in understanding systems like: - Particle accelerators \u2013 guiding and accelerating beams. - Mass spectrometers \u2013 separating particles based on mass-to-charge ratio. - Plasma confinement devices (e.g., tokamaks) \u2013 controlling plasma using magnetic fields. Understanding the Lorentz force enables the design and analysis of such systems. 2. Lorentz Force Equation The Lorentz force \\(\\vec{F}\\) acting on a charged particle is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\(q\\) : Charge of the particle - \\(\\vec{E}\\) : Electric field - \\(\\vec{B}\\) : Magnetic field - \\(\\vec{v}\\) : Particle velocity Using Newton\u2019s Second Law: \\[ \\vec{F} = m \\frac{d\\vec{v}}{dt} \\] We obtain the equation of motion: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This equation is generally solved numerically due to the complexity of \\(\\vec{v} \\times \\vec{B}\\) . 3. Simulation Overview We simulate particle trajectories using the 4th-order Runge-Kutta method for accuracy. Scenarios Simulated: 1. Uniform magnetic field only: Circular motion. 2. Parallel \\(\\vec{E}\\) and \\(\\vec{B}\\) : Helical motion. 3. Crossed fields: Drift motion. Parameters that can be varied: - Electric field strength \\(\\vec{E}\\) - Magnetic field strength \\(\\vec{B}\\) - Initial velocity \\(\\vec{v}_0\\) - Charge \\(q\\) and mass \\(m\\) 4. Code Implementation See the attached Python script for full implementation: RK4 integration, Lorentz force application, and 3D visualization. # Lorentz Force Simulation and Visualization import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and Parameters def lorentz_force(q, v, E, B): return q * (E + np.cross(v, B)) # Runge-Kutta 4th order integrator def rk4_step(pos, vel, dt, q, m, E, B): def acceleration(v): return lorentz_force(q, v, E, B) / m k1v = dt * acceleration(vel) k1x = dt * vel k2v = dt * acceleration(vel + 0.5 * k1v) k2x = dt * (vel + 0.5 * k1v) k3v = dt * acceleration(vel + 0.5 * k2v) k3x = dt * (vel + 0.5 * k2v) k4v = dt * acceleration(vel + k3v) k4x = dt * (vel + k3v) new_vel = vel + (k1v + 2*k2v + 2*k3v + k4v)/6 new_pos = pos + (k1x + 2*k2x + 2*k3x + k4x)/6 return new_pos, new_vel # Simulation function def simulate_motion(E, B, q, m, v0, r0, dt=1e-9, steps=1000): positions = [r0] velocities = [v0] pos, vel = r0, v0 for _ in range(steps): pos, vel = rk4_step(pos, vel, dt, q, m, E, B) positions.append(pos) velocities.append(vel) return np.array(positions), np.array(velocities) # Visualization function def plot_trajectory(positions, title=\"Particle Trajectory\"): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:,0], positions[:,1], positions[:,2]) ax.set_title(title) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') plt.show() # Example scenarios q = 1.6e-19 # Charge (C) m = 9.11e-31 # Mass (kg) v0 = np.array([1e6, 0, 0]) r0 = np.array([0, 0, 0]) # Uniform magnetic field only E1 = np.array([0, 0, 0]) B1 = np.array([0, 0, 1]) pos1, vel1 = simulate_motion(E1, B1, q, m, v0, r0) plot_trajectory(pos1, title=\"Circular Motion in Magnetic Field\") # Electric and magnetic fields parallel E2 = np.array([0, 0, 1e5]) B2 = np.array([0, 0, 1]) pos2, vel2 = simulate_motion(E2, B2, q, m, v0, r0) plot_trajectory(pos2, title=\"Helical Motion in E & B Fields\") # Crossed electric and magnetic fields E3 = np.array([0, 1e5, 0]) B3 = np.array([0, 0, 1]) pos3, vel3 = simulate_motion(E3, B3, q, m, v0, r0) plot_trajectory(pos3, title=\"Drift Motion in Crossed E & B Fields\") 5. Results and Visualizations Case 1: Circular Motion \\(\\vec{E} = 0\\) \\(\\vec{B} = [0, 0, B]\\) Initial velocity perpendicular to \\(\\vec{B}\\) Expected motion: circular From theory: \\[ r_L = \\frac{mv}{|q||B|} \\quad \\text{(Larmor radius)} \\] Plot: [Circular orbit in x-y plane] Case 2: Helical Motion \\(\\vec{E} = [0, 0, E]\\) \\(\\vec{B} = [0, 0, B]\\) Expected motion: helix, as velocity has components both parallel and perpendicular to \\(\\vec{B}\\) . Plot: [3D helical path] Case 3: Crossed Fields (Drift) \\(\\vec{E} = [0, E, 0]\\) Case 3: Crossed Fields (Drift) \\(\\vec{E} = [0, E, 0]\\) \\(\\vec{B} = [0, 0, B]\\) Expected motion: drift velocity in x-direction: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Plot: [Curved motion with net drift] \u0130nteractive simulation with sliders import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from ipywidgets import interact, FloatSlider import ipywidgets as widgets # Lorentz Force def lorentz_force(q, v, E, B): return q * (E + np.cross(v, B)) # RK4 Integrator def rk4_step(pos, vel, dt, q, m, E, B): def acceleration(v): return lorentz_force(q, v, E, B) / m k1v = dt * acceleration(vel) k1x = dt * vel k2v = dt * acceleration(vel + 0.5 * k1v) k2x = dt * (vel + 0.5 * k1v) k3v = dt * acceleration(vel + 0.5 * k2v) k3x = dt * (vel + 0.5 * k2v) k4v = dt * acceleration(vel + k3v) k4x = dt * (vel + k3v) new_vel = vel + (k1v + 2*k2v + 2*k3v + k4v)/6 new_pos = pos + (k1x + 2*k2x + 2*k3x + k4x)/6 return new_pos, new_vel # Simulation def simulate_motion(E, B, q, m, v0, r0, dt=1e-11, steps=2000): positions = [r0] pos, vel = r0.copy(), v0.copy() for _ in range(steps): pos, vel = rk4_step(pos, vel, dt, q, m, E, B) positions.append(pos) return np.array(positions) # Interactive plot function def interactive_lorentz_sim(q=1.6e-19, m=9.11e-31, Ex=0.0, Ey=0.0, Ez=0.0, Bx=0.0, By=0.0, Bz=1.0, v0x=1e6, v0y=0.0, v0z=0.0): E = np.array([Ex, Ey, Ez]) B = np.array([Bx, By, Bz]) v0 = np.array([v0x, v0y, v0z]) r0 = np.array([0.0, 0.0, 0.0]) positions = simulate_motion(E, B, q, m, v0, r0) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('Charged Particle Trajectory (Lorentz Force)') plt.show() # Create interactive sliders interact( interactive_lorentz_sim, Ex=FloatSlider(min=-1e6, max=1e6, step=1e5, value=0.0, description='E_x'), Ey=FloatSlider(min=-1e6, max=1e6, step=1e5, value=0.0, description='E_y'), Ez=FloatSlider(min=-1e6, max=1e6, step=1e5, value=0.0, description='E_z'), Bx=FloatSlider(min=-5, max=5, step=0.5, value=0.0, description='B_x'), By=FloatSlider(min=-5, max=5, step=0.5, value=0.0, description='B_y'), Bz=FloatSlider(min=-5, max=5, step=0.5, value=1.0, description='B_z'), v0x=FloatSlider(min=0, max=2e6, step=1e5, value=1e6, description='v0_x'), v0y=FloatSlider(min=0, max=2e6, step=1e5, value=0.0, description='v0_y'), v0z=FloatSlider(min=0, max=2e6, step=1e5, value=0.0, description='v0_z') ) What it does ? \u26a1\ufe0f Interactive Lorentz Force Simulation \ud83d\udd0d What It Does This code simulates the motion of a charged particle under electric and magnetic fields using the Lorentz force: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] \ud83d\udee0 Features Uses Runge-Kutta 4th order method for accurate motion updates Provides sliders to adjust: \\(\\vec{E}\\) , \\(\\vec{B}\\) field components Initial velocity components Displays 3D trajectory of the particle in real time \ud83c\udfaf Purpose Helps visualize how different field setups affect particle motion \u2014 such as circular, helical, or drifting paths. Link to the interactive simulation: https://colab.research.google.com/drive/17Ii1vDdz-1lLsmpS8hFB4P0gQn_fb6nJ#scrollTo=kaCkWEGUDROL&line=78&uniqifier=1 https://colab.research.google.com/drive/1eAPl8v0tXUfGH_QkqfvQFNFxfENQNp_i#scrollTo=7CHEi8_1p0Z0 6. Real-World Relevance Cyclotrons exploit circular motion in magnetic fields. Magnetic traps and Penning traps confine particles using combined E and B fields. In space physics, the Earth\u2019s magnetic field and solar wind electric fields produce drift phenomena. 7. Extensions and Improvements Possible future improvements: - Non-uniform \\(\\vec{B}(x, y, z)\\) - Collisions or friction forces - Relativistic effects at high speeds - External potentials (e.g., gravitational field)","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction-and-motivation","text":"The Lorentz force governs the motion of charged particles in electromagnetic fields and is essential in understanding systems like: - Particle accelerators \u2013 guiding and accelerating beams. - Mass spectrometers \u2013 separating particles based on mass-to-charge ratio. - Plasma confinement devices (e.g., tokamaks) \u2013 controlling plasma using magnetic fields. Understanding the Lorentz force enables the design and analysis of such systems.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-lorentz-force-equation","text":"The Lorentz force \\(\\vec{F}\\) acting on a charged particle is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\(q\\) : Charge of the particle - \\(\\vec{E}\\) : Electric field - \\(\\vec{B}\\) : Magnetic field - \\(\\vec{v}\\) : Particle velocity Using Newton\u2019s Second Law: \\[ \\vec{F} = m \\frac{d\\vec{v}}{dt} \\] We obtain the equation of motion: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This equation is generally solved numerically due to the complexity of \\(\\vec{v} \\times \\vec{B}\\) .","title":"2. Lorentz Force Equation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-simulation-overview","text":"We simulate particle trajectories using the 4th-order Runge-Kutta method for accuracy. Scenarios Simulated: 1. Uniform magnetic field only: Circular motion. 2. Parallel \\(\\vec{E}\\) and \\(\\vec{B}\\) : Helical motion. 3. Crossed fields: Drift motion. Parameters that can be varied: - Electric field strength \\(\\vec{E}\\) - Magnetic field strength \\(\\vec{B}\\) - Initial velocity \\(\\vec{v}_0\\) - Charge \\(q\\) and mass \\(m\\)","title":"3. Simulation Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-code-implementation","text":"See the attached Python script for full implementation: RK4 integration, Lorentz force application, and 3D visualization. # Lorentz Force Simulation and Visualization import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and Parameters def lorentz_force(q, v, E, B): return q * (E + np.cross(v, B)) # Runge-Kutta 4th order integrator def rk4_step(pos, vel, dt, q, m, E, B): def acceleration(v): return lorentz_force(q, v, E, B) / m k1v = dt * acceleration(vel) k1x = dt * vel k2v = dt * acceleration(vel + 0.5 * k1v) k2x = dt * (vel + 0.5 * k1v) k3v = dt * acceleration(vel + 0.5 * k2v) k3x = dt * (vel + 0.5 * k2v) k4v = dt * acceleration(vel + k3v) k4x = dt * (vel + k3v) new_vel = vel + (k1v + 2*k2v + 2*k3v + k4v)/6 new_pos = pos + (k1x + 2*k2x + 2*k3x + k4x)/6 return new_pos, new_vel # Simulation function def simulate_motion(E, B, q, m, v0, r0, dt=1e-9, steps=1000): positions = [r0] velocities = [v0] pos, vel = r0, v0 for _ in range(steps): pos, vel = rk4_step(pos, vel, dt, q, m, E, B) positions.append(pos) velocities.append(vel) return np.array(positions), np.array(velocities) # Visualization function def plot_trajectory(positions, title=\"Particle Trajectory\"): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:,0], positions[:,1], positions[:,2]) ax.set_title(title) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') plt.show() # Example scenarios q = 1.6e-19 # Charge (C) m = 9.11e-31 # Mass (kg) v0 = np.array([1e6, 0, 0]) r0 = np.array([0, 0, 0]) # Uniform magnetic field only E1 = np.array([0, 0, 0]) B1 = np.array([0, 0, 1]) pos1, vel1 = simulate_motion(E1, B1, q, m, v0, r0) plot_trajectory(pos1, title=\"Circular Motion in Magnetic Field\") # Electric and magnetic fields parallel E2 = np.array([0, 0, 1e5]) B2 = np.array([0, 0, 1]) pos2, vel2 = simulate_motion(E2, B2, q, m, v0, r0) plot_trajectory(pos2, title=\"Helical Motion in E & B Fields\") # Crossed electric and magnetic fields E3 = np.array([0, 1e5, 0]) B3 = np.array([0, 0, 1]) pos3, vel3 = simulate_motion(E3, B3, q, m, v0, r0) plot_trajectory(pos3, title=\"Drift Motion in Crossed E & B Fields\")","title":"4. Code Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-results-and-visualizations","text":"","title":"5. Results and Visualizations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-1-circular-motion","text":"\\(\\vec{E} = 0\\) \\(\\vec{B} = [0, 0, B]\\) Initial velocity perpendicular to \\(\\vec{B}\\) Expected motion: circular From theory: \\[ r_L = \\frac{mv}{|q||B|} \\quad \\text{(Larmor radius)} \\] Plot: [Circular orbit in x-y plane]","title":"Case 1: Circular Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-2-helical-motion","text":"\\(\\vec{E} = [0, 0, E]\\) \\(\\vec{B} = [0, 0, B]\\) Expected motion: helix, as velocity has components both parallel and perpendicular to \\(\\vec{B}\\) . Plot: [3D helical path]","title":"Case 2: Helical Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-3-crossed-fields-drift","text":"\\(\\vec{E} = [0, E, 0]\\)","title":"Case 3: Crossed Fields (Drift)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-3-crossed-fields-drift_1","text":"\\(\\vec{E} = [0, E, 0]\\) \\(\\vec{B} = [0, 0, B]\\) Expected motion: drift velocity in x-direction: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Plot: [Curved motion with net drift]","title":"Case 3: Crossed Fields (Drift)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#interactive-simulation-with-sliders","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from ipywidgets import interact, FloatSlider import ipywidgets as widgets # Lorentz Force def lorentz_force(q, v, E, B): return q * (E + np.cross(v, B)) # RK4 Integrator def rk4_step(pos, vel, dt, q, m, E, B): def acceleration(v): return lorentz_force(q, v, E, B) / m k1v = dt * acceleration(vel) k1x = dt * vel k2v = dt * acceleration(vel + 0.5 * k1v) k2x = dt * (vel + 0.5 * k1v) k3v = dt * acceleration(vel + 0.5 * k2v) k3x = dt * (vel + 0.5 * k2v) k4v = dt * acceleration(vel + k3v) k4x = dt * (vel + k3v) new_vel = vel + (k1v + 2*k2v + 2*k3v + k4v)/6 new_pos = pos + (k1x + 2*k2x + 2*k3x + k4x)/6 return new_pos, new_vel # Simulation def simulate_motion(E, B, q, m, v0, r0, dt=1e-11, steps=2000): positions = [r0] pos, vel = r0.copy(), v0.copy() for _ in range(steps): pos, vel = rk4_step(pos, vel, dt, q, m, E, B) positions.append(pos) return np.array(positions) # Interactive plot function def interactive_lorentz_sim(q=1.6e-19, m=9.11e-31, Ex=0.0, Ey=0.0, Ez=0.0, Bx=0.0, By=0.0, Bz=1.0, v0x=1e6, v0y=0.0, v0z=0.0): E = np.array([Ex, Ey, Ez]) B = np.array([Bx, By, Bz]) v0 = np.array([v0x, v0y, v0z]) r0 = np.array([0.0, 0.0, 0.0]) positions = simulate_motion(E, B, q, m, v0, r0) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('Charged Particle Trajectory (Lorentz Force)') plt.show() # Create interactive sliders interact( interactive_lorentz_sim, Ex=FloatSlider(min=-1e6, max=1e6, step=1e5, value=0.0, description='E_x'), Ey=FloatSlider(min=-1e6, max=1e6, step=1e5, value=0.0, description='E_y'), Ez=FloatSlider(min=-1e6, max=1e6, step=1e5, value=0.0, description='E_z'), Bx=FloatSlider(min=-5, max=5, step=0.5, value=0.0, description='B_x'), By=FloatSlider(min=-5, max=5, step=0.5, value=0.0, description='B_y'), Bz=FloatSlider(min=-5, max=5, step=0.5, value=1.0, description='B_z'), v0x=FloatSlider(min=0, max=2e6, step=1e5, value=1e6, description='v0_x'), v0y=FloatSlider(min=0, max=2e6, step=1e5, value=0.0, description='v0_y'), v0z=FloatSlider(min=0, max=2e6, step=1e5, value=0.0, description='v0_z') )","title":"\u0130nteractive simulation with sliders"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-does","text":"\u26a1\ufe0f Interactive Lorentz Force Simulation \ud83d\udd0d What It Does This code simulates the motion of a charged particle under electric and magnetic fields using the Lorentz force: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] \ud83d\udee0 Features Uses Runge-Kutta 4th order method for accurate motion updates Provides sliders to adjust: \\(\\vec{E}\\) , \\(\\vec{B}\\) field components Initial velocity components Displays 3D trajectory of the particle in real time \ud83c\udfaf Purpose Helps visualize how different field setups affect particle motion \u2014 such as circular, helical, or drifting paths.","title":"What it does ?"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#link-to-the-interactive-simulation","text":"https://colab.research.google.com/drive/17Ii1vDdz-1lLsmpS8hFB4P0gQn_fb6nJ#scrollTo=kaCkWEGUDROL&line=78&uniqifier=1 https://colab.research.google.com/drive/1eAPl8v0tXUfGH_QkqfvQFNFxfENQNp_i#scrollTo=7CHEi8_1p0Z0","title":"Link to the interactive simulation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-real-world-relevance","text":"Cyclotrons exploit circular motion in magnetic fields. Magnetic traps and Penning traps confine particles using combined E and B fields. In space physics, the Earth\u2019s magnetic field and solar wind electric fields produce drift phenomena.","title":"6. Real-World Relevance"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-extensions-and-improvements","text":"Possible future improvements: - Non-uniform \\(\\vec{B}(x, y, z)\\) - Collisions or friction forces - Relativistic effects at high speeds - External potentials (e.g., gravitational field)","title":"7. Extensions and Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}